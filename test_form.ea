(define lambda (fixed %lambda %encode-lambda))
(define let    (fixed %let    %encode-let))
(define if     (fixed %if))
(define and    (fixed %and))
(define or     (fixed %or))
(define set    (fixed %set))
(define delay  (fixed %delay))

(define cadr (lambda (x) (car (cdr x))))
(define cddr (lambda (x) (cdr (cdr x))))

(define concat-list
   (lambda (x y)
      (if (pair? x)
            (cons (car x) (concat-list (cdr x) y))
         y)))

(mark-time 17)

(define expand-quote
   (let ((qq-list) (qq-element) (qq-object))
      (set qq-list (lambda (l)
                      (if (pair? l)
                            (let ((obj (car l))
                                  (rst (cdr l)))
                               (if (and (pair? obj)
                                        (== (car obj) 'unquote-splicing))
                                     (let ((value (cadr obj)))
                                        (if rst
                                              (list 'concat-list value (qq-list rst))
                                           value))
                                  (list 'cons (qq-object obj) (qq-list rst))))
                         (list 'quote l))))
      (set qq-element (lambda (l)
                         (let ((head (car l)))
                            (if (== head 'unquote)
                                  (cadr l)
                               (qq-list l)))))
      (set qq-object (lambda (object)
                        (if (pair? object)
                              (qq-element object)
                           (list 'quote object))))
      qq-object))

(mark-time 45)

(define quasiquote (form expand-quote))

(dumpln (let ((%define 'define)
              (name 'fooness)
              (args '(one two three))
              (body '(and one anda two)))
           `(\%define \name (lambda \args \@body))))


(mark-time 56)

(define %define-with (lambda (%define)
                        (lambda (pattern . body)
                           (if (pair? pattern)
                                 (let ((name (car pattern))
                                       (args (cdr pattern)))
                                    `(\%define \name (lambda \args \@body)))
                              `(\%define \pattern \@body)))))


(mark-time 67)

(define %define-kind (lambda (%define %kind)
                        (lambda (pattern . body)
                           (if (pair? pattern)
                                 (let ((name (car pattern))
                                       (args (cdr pattern)))
                                    `(\%define \name (\%kind (lambda \args \@body))))
                              `(\%define \pattern (\%kind \@body))))))


(mark-time 78)


(define expand-define (%define-with define))

(mark-time)

(define expand-macro  (%define-kind define form))

(mark-time 86)

(define define (form expand-define))
(define macro  (form expand-macro))

(dumpln (apply expand-define
               '((list-length list)
                 (if (pair? list)
                       (+ 1 (list-length (cdr list)))
                    0))))

(define (list-length-cooked list)
   (if (pair? list)
         (+ 1 (list-length-cooked (cdr list)))
      0))

(dumpln "cooked list-length" (list-length-cooked '(1 2 3 4)))

(dumpln (apply expand-define '(x y z)))

(dumpln (apply expand-macro
               '((begin . body)
                 `(let () \@body))))



(macro (begin . body)
   `(let () \@body))

(begin 
   (print 1)
   (print 2)
   (println 3))


(define expand-let* (lambda (bindings body)
                       (if (pair? (cdr bindings))
                             `(let (\(car bindings)) \(expand-let* (cdr bindings) body))
   `(let \bindings \@body))))

(dumpln (apply expand-let* '(((x 1)(y 2)(z 3)) (do-it))))

(dumpln "End")
