
<core> = <object>
       | <variable>
       | (quote <object>)
       | (lambda <arguments> <core>)
       | (if <core> <core> <core>)
       | (set <variable> <core>)
       | (define <variable> <core>)
       | (call/cc <core>)
       | (form <core>)
       | (<core> <core>*)

<arguments> = ()
            | <variable>
            | (<variable>+)
            | (<variable>+ . <variable>)

-------- possible change ----------

<core> = <object>
       | <lname>
       | <gname>
       | (quote <object>)
       | (transform <core>)
       | (lambda <type-expr> <arguments> <core>)
       | (if <core> <core> <core>)
       | (define <gname> <core>)
       | (let <locals> <assigns> <core>)
       | (fix <locals> <assigns> <core>)
       | (delay <type-expr> <core>)
       | (effect <core>)
       | (<core> <core>*)

<type> =

<object> := a literal value
<lname>  := a local name 
<gname>  := a global name

<type> = [] 
       | [<type-expr>]

<locals> = ( <local>+ )
<local>  = <lname> <type>

<assigns> = <assign>+
<assign>  = (set <lname> <core>)

<arguments> = ()
            | <lname>
            | ( <lname>+ )
            | ( <lname>+ . <lname> )

quote   := construct a AST
form    := construct a AST tranformer value
lambda  := construct a lambda value
if      := construct if conditional
define  := define/update global name
let     := declare a local scope assigned from outer scope
fix     := declare a local scope assigned from inner scope
delay   := construct a delayed thunk
effect  := evaluate a delayed thunk without updating it



-------- references ----------
  http://lib.store.yahoo.net/lib/paulgraham/jmc.lisp
  http://www.ccs.neu.edu/home/dorai/mbe/mbe-lsp.html
  http://www.iro.umontreal.ca/~boucherd/mslug/meetings/20041020/minutes-en.html
  https://github.com/kragen/stoneknifeforth
  http://www.andreadrian.de/tbng/
  http://web.archive.org/web/20060924123915/http://www.rano.org/bcompiler.html
  http://homepage.ntlworld.com/edmund.grimley-evans/cc500/
  http://www.bayfronttechnologies.com/mc_tutorial.html 
  http://www.ibm-1401.info/Meta-II-schorre.pdf
  http://arclanguage.org/

-------- scheme type system --

  http://wiki.call-cc.org/man/4/Types

-------- combinator ----------

(define Y (lambda (f) ((lambda (a) (a a)) (lambda (b) (f (lambda (c) ((b b) c)))))))

-------- macros --------------

(begin exp1) -> exp1
(begin exp1 exp2 ... ) -> ((lambda (x) (begin exp2 ... )) exp1)

(let ([var val] ... ) exp ... ) -> ((lambda (var ... ) (begin exp ...)) val ... )

(let label ([var val] ... ) exp ... ) -> ((Y (lambda (label var ... ) (begin exp ... ))) val ... )

(rec var exp) -> (let ([var '()]) (set! var exp))

(recur f ([var init] ... ) exp ... ) -> ((rec f (lambda (var ... ) (begin exp ... ))) init ... )

(and exp1) -> exp1
(and exp1 exp2 ... ) -> (if exp1 (and exp2 ... ) '())

(or exp1) -> exp1
(or exp1 exp2 ... ) -> (if exp1 't (or exp2 ... ))

(when test exp ... ) -> (if test (begin exp ... ) '())

(unless test exp ... ) -> (if test '() (begin exp ... ))

(record (var ... ) val exp ... ) -> (apply (lambda (var ... ) (begin exp ... )) val)

(cond [else exp ... ]) -> (begin exp ... )
(cond [test exp ... ] clause ... ) -> (if test (begin exp ... ) (cond clause ... ))
                 
------------------

(head a... (call/cc yyy) b...) -> (apply yyy (lambda (xxx) (head a... xxx b...)))


