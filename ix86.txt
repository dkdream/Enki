Purpose

Although the main registers (with the exception of the instruction pointer) are "general-purpose" and can be used for anything,
it was originally envisioned that they be used for the following purposes:

    AX /EAX /RAX: Accumulator
    BX /EBX /RBX: Base index (for use with arrays)
    CX /ECX /RCX: Counter
    DX /EDX /RDX: Data/general
--------------------------------------------------------------
    SI /ESI /RSI: Source index for string operations.
    DI /EDI /RDI: Destination index for string operations.
--------------------------------------------------------------
    SP /ESP /RSP: Stack pointer for top address of the stack.
    BP /EBP /RBP: Stack base pointer for holding the address of the current stack frame.
    IP /EIP /RIP: Instruction pointer. Holds the program counter, the current instruction address.

Segment registers:

    CS: Code
    DS: Data
    SS: Stack
    ES: Extra
    FS
    GS
--------------------------
http://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax
http://en.wikibooks.org/wiki/X86_Assembly
--------------------------
address operand syntax : 
   <disp>(<r1>, <r2>, <scale>)
=
   (<r1> + <disp>) + (<r2> * <scale>)

example:
   movl -4(%ebp, %edx, 4), %eax -> eax = mem[(ebp - 4) + (edx * 4)]
   movl -4(%ebp), %eax          -> eax = mem[(ebp - 4) + (0   * 0)]
   movl  8(,%eax,4), %eax       -> eax = mem[(0   + 8) + (edx * 4)]
   movl   (%eax,%eax,2), %eax   -> eax = mem[(eax + 0) + (eax * 2)]
--
   leal  8(,%eax,4), %eax       -> eax = (0   + 8) + (edx * 4)
   leal   (%eax,%eax,2), %eax   -> eax = (eax + 0) + (%eax * 2)
--------------------------
pushl %eax = subl $4,%esp
             movl %eax, (%esp)
popl  %eax = movl (%esp),%eax
             addl $4,%esp
leave = movl %ebp,%esp
        popl %ebp
call $0x12345 = pushl %eip
                movl $0x12345,%eip
ret = popl %eip

-------------------------- 
(gcc) caller-saved : %eax, %ecx, %edx, 
(gcc) callee-saved : %ebx, %esi, %edi, %esp, %ebp
(gcc) return-value : %eax

--------------------------
(gcc) standard enter sequence

   pushl %ebp # 
   movl  %esp, %ebp
   subl  $qq, %esp  #(alloca local and scratch)

(gcc) extended enter sequence

   pushl %ebp # 
   movl  %esp, %ebp
   pushl %ebx
   pushl %esi
   pushl %edi
   subl  $qq, %esp #(alloca local and scratch)

now the stack looks like

ebp+xx arg(n)
       arg(n-1)
       ..
       arg(2)
ebp+8  arg(1)
ebp+4  return-pointer
ebp -> old-frame
       saved(r1)
       ...
       saved(rn)
       local(1)
       local(2)
       ...
       local(n-1)
ebp-yy local(n)
esp+zz scratch(n)
       scratch(n-1)
       ...
       scratch(2)
esp->  scratch(1)

-------------
(gcc) standard return sequence

  movl <result>, %eax
  movl %ebp,%esp
  popl %ebp
  ret

(gcc) extended return sequence
  
  movl <result>, %eax
  subl $qq,%esp
  popl %edi
  popl %esi
  popl %ebx
  popl %ebp
  ret

-------------
(enki) registier assignment

  %eax - arg count/ret value
  %esp - stack pointer
  %ebp - frame pointer

-------------
(enki) caller-saved   : %eax, %ebx, %ecx, %edx, %esi, %edi, 
(enki) callee-saved   : %esp, %ebp 
----------------------------
(enki) argument-count : %eax
(enki) argument_1     : %ebx
(enki) argument_2     : %ecx
(enki) argument_3     : %edx
(enki) closure        : %esi
(enki) frame-bottom   : %edi
----------------------------
(enki) return-value   : %eax

------------
(enki) stack layout after call

eax = (size-of argument-frame) or (zero if register-only) 
ebp = prev-frame-pointer

esp -> return-pointer
       arg(4)
       arg(5)
       ...
       arg(n-1)
edi -> arg(n)


(enki) standard enter sequence

   xchgl %edi,%esp   
   pushl %ebp
   xchgl %edi,%ebp 

(enki) stack layout after enter sequence

ebp -> return-pointer
 -4    arg(4)
 -8    arg(5)
       ...
       arg(n-1)
       arg(n)
esp -> old-frame-pointer
 -4    scratch(1)
 -8    scratch(2)
       ...
       scratch(n-1)
       scratch(n)

(enki) standard return sequence
 
   movl <result>, %eax
   movl %ebp, %edi
   popl %ebp
   movl %edi, %esp
   ret

----------

 
