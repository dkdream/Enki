
##
## control-tree -> execution-tree (only-lambdas)
## 
(define (analyzer exp)
   (let (make-let-bindings control-analyzer cbegin)
      (define (constant value)
         (lambda (env) value))
      
      (define (recall name)
         (lambda (env) 
            (let ((value (find-value name env)))
               (if (forced? value)
                     (forced-value value)
                  value))))
      
      (define (store name value)
         (lambda (env) 
            (update-bindings name (value env) env)))
      
      (define (external name value)
         (lambda (env)
            (global-add name (value env))))
      
      (define (choose test on_true on_false)
         (lambda (env)
            (if (test env)
                  (on_true env)
               (on_false env))))
      
      (define (first-true first next)
         (lambda (env)
            (let ((value (first env)))
               (if value
                     value
                  (next env)))))
      
      (define (first-false first next)
         (lambda (env)
            (let ((value (first env)))
               (if value
                     (next env)
                  value))))
      
      (define (sequence first next)
         (lambda (env)
            (first env)
            (next env)))
      
      (define (make-lambda vars body))
      
      (define (execute function args)
         (application function args))
      
      (define (evaluator exp env)
         ((analyzer exp) env)))

      ## do-analy           - convert an control-tree argument into a value
      ## make-let-bindings - create and extended enviroment
      ## control-analyzer - convert a control-tree structure into a value
      (set cbegin (find-value 'begin controls))
      (set (make-let-bindings bindings)
           (if (nil? bindings)
                 env
              (let ((entry (car bindings))
                    (tail  (make-let-bindings (cdr bindings))))
                 (cond ((symbol? entry) (cons (cons entry nil) tail))
                       ((pair?  entry) (cons (cons (car entry) 
                                                   (analyzer (car (cdr entry)) env))
                                             tail))
                       ((tuple? entry) (cons (cons (element entry 0)
                                                   (analyzer (element entry 1) env))
                                             tail))))))
      (set (control-analyzer control args)
           (let (check name)
              (set name (control-name control))
              (set (check symbol) (== symbol name))
              (cond ((check 'define) (external (car args) (car (cdr args))))
                    ((check 'quote)  (const (car args)))
                    ((check 'type)   (const (type args)))
                    ((check 'if)     (choose (analyzer (car args))
                                             (analyzer (car (cdr args)))
                                             (control-analyzer cbegin (cdr (cdr args)))))
                    ((check 'unless) (choose (analyzer (car args))
                                             (control-analyzer cbegin (cdr (cdr args)))
                                             (analyzer (car (cdr args)))))
                    ((check 'and)    (if (nil? args)
                                           (constant true)
                                        (if (nil? (cdr args))
                                              (analyzer (car args))
                                           (first-true (analyzer (car args))
                                                       (control-analyzer control (cdr args))))))
                    ((check 'or)     (if (nil? args)
                                           (constant nil)
                                        (if (nil? (cdr args))
                                              (analyzer (car args))
                                           (first-false (analyzer (car args))
                                                        (control-analyzer control (cdr args))))))
                    ((check 'set)   (store (car args)
                                           (analyzer (car (cdr args)))))
                    ((check 'begin)  (if (nil? args)
                                           (const nil)
                                        (if (nil? (cdr args))
                                              (analyzer (car args))
                                           (sequence (analyzer (car args))
                                                     (control-analyzer control (cdr args))))))
                    ((check 'lambda) (make-lambda (car args)
                                                  (analyzer (cons cbegin (cdr args)))))
                    ((check 'apply)  (let ((fproc (analyzer (car args)))
                                           (vals  (map analyzer (car (cdr args)))))
                                        (lambda (env)
                                           (execute (fproc env)
                                                    (map (lambda (aproc) (aproc env)) vals)))))
                    )))
      (cond ((primitive? exp) (constant exp))
            ((control?   exp) (constant exp))
            ((symbol?    exp) (recall exp))
            ((pair?      exp) (control-analyzer capply exp)
            ((tuple?     exp) (constant exp))
            ((text?      exp) (constant exp))
            ((integer?   exp) (constant exp))
            ((nil?       exp) (constant exp))
            ((comma?     exp) (error 'ANALYZER "comma not supported (yet)" exp))
            ((semi?      exp) (error 'ANALYZER "semi not supported (yet)" exp))
            ((block?     exp) (error 'ANALYZER "block not supported (yet)" exp))
            (else exp))))


##
## control-tree -> instruction-sequence
## 
## model the compile function after the evaluator function
## - where the enviroment is a list of definitions [ symbol registor ] and frames [ argCount localCount boxList escapingList ]
## each lambda control constructs a frame [ argCount 0 nil nil ] and adds it to the enviroment followed by the its definitions.
## each let extends the enviroment and then count the local registor up to the first frame and the update the localCount
## each variable reference update all frames from the point of access to the definition and may add to the enviroment.
##
## each registor is one of four types (global,closure,argument,local) and two kinds (box,unbox)
## if a closure registor is the target of a set control it is changed to a box values
##
## registors is
## the escapingList is a list of definitions
## the search order
##   1) enviroment up to the first frame if found return registor
##   2) push frame
##   3) search up to the next frame if found (4) otherwise (2)
##   4) set result to found registor
##   5) pop frame and add result to escapingList and create a new closure registor and set result 
##   6) is stack empty? onTrue return result otherwise (5) 
##
## - instruction need to now what frame they are compiled
## - local variables and arguments are marked as named registors
## - 'test     is a machine registor reserved for test values
## - 'result   is a machine registor for temparary and return values
## - all instructions take only registors or labels as arguments
## 
## (make-registor name kind [index])
## - when each registor is make it is marks as local, parameter or global
## - it may be marked later as closure (only on parameter and local)
##
## (registor name frame)
## - return the registor 'name from the current frame
##
## (instruction command . args)
## command
##   'bind    target-reg value-reg
##   'set     target-reg value-reg
##   'goto    label
##   'onTrue  label
##   'onFalse label
##   'return  value-reg
##   'closure target-reg arg0-reg..argn-reg
##   'call    address-reg closure-reg arg0-reg..argn-reg
##   'tail    address-reg closure-reg arg0-reg..argn-reg
##   'tuple   target-reg count-reg
##   'store   tuple-reg index-reg value-reg
##   'push    value-reg
##   'pop     target-reg
##   'marker  label
##
## the (instruction 'bind ..) is resposible for allocation closure boxes
## the (registor ...)         is resposible for converting parameter and local registors to closure registors
###
###
###
###

(define (let-frame locals)
   ## let-frame [ localCount boxList ]
   (type-of (tuple (length locals) nil) :let_frame))

(define (lambda-frame arguments)
   ## lambda-frame [ argumentCount localCount boxedList escapingList ]
   (type-of (tuple (length arguments) 0 nil nil) :lambda_frame))

(define (lambda-extend arguments enviroment)
   (let (add-binding extend-env frame)
      (set (add-binding symbol index env)
           (let ((registor (arg-registor index)))
              (cons (cons symbol registor) env)))
      (set (extend-env args index env)
           (if (pair? args)
                 (add-binding (car args) index (extend-env (cdr arg) (+ index 1) env))
              env))
      (set frame (lambda-frame arguments))
      (extend-env arguments 0 (cons frame enviroment))))
            
(define (let-extend offset locals enviroment)
   (let (add-binding extend-env frame)
      (set (add-binding entry index env)
           (cons ((symbol? entry) (let ((registor (lcl-registor index)))
                                     (cons (cons entry registor) env)))
                 ((pair? entry) (let ((registor (lcl-registor index)))
                                   (cons (cons (car entry) registor) env)))
                 ((tuple? entry) (let ((registor (lcl-registor index)))
                                    (cons (cons (element entry 0) registor) env)))
                 (else (error 'LET-EXTEND (format "invalid entry %" entry)))))
                 

            
(define (instruction command . list)
   (type-of (tuple command list) :instruction)

(define (label name)
   (type-of (tuple name) :label)

(define (flatten statements)
   (let ((head (car statements))
         (tail (cdr statements)))
      (if (pair? head)
            (append (flatten head) (flatten tail))
         (cons head (flatten tail)))))

(define (sequence needs modifies . list)
   (if (and (all? needs 'symbol)
            (all? modified 'symbol))
         (let ((statements (flatten list)))
            (if (all? :instruction statements)
                  (let ((result (tuple needs modifies statements)))
                     (type-of result :sequence)
                     result))
            (error 'SEQUENCE "non-instruction in statements")))
      (error 'SEQUENCE "non-symbol in needs or modifies")))

(define (needs-register? sequence register)
   (if (isA? sequence :sequence)
         (if (isA? register 'symbol)
               (member register (element sequence 0)))))

(define (modifies-register? sequence register) 
   (if (isA? sequence :sequence)
         (if (isA? register 'symbol)
               (member register (element sequence 1)))))

(define (union alist blist)
   (if (nil? alist)
         blist
      (let ((head (car alist))
            (tail (cdr alist)))
         (if (member head blist)
               (union tail blist)
            (cons head (union tail blist))))))

(define (difference list minus)
   (if (nil? list)
         nil
      (let ((head (car list))
            (tail (cdr list)))
         (if (member head minus)
               (difference tail minus)
            (cons head (difference tail minus))))))

(define empty-sequence (sequence nil nil))

(define (append-sequence first next)
   (sequence (union (element first 0)
                    (difference (element next 0)
                                (element first 1)))
             (union (element first 1)
                    (element next 1))
             (element first 2)
             (element next 2)))

(define (append-preserving registors first next)
   (if (nil? registors)
         (append-sequence first next)
      (let ((register (car registors)))
         (if (and (needs-register? first register)
                  (modifies-register? next register))
               (preserving (cdr regs)
                           (instruction-sequence (union (list register) (element first 0))
                                                 (difference (element first 1) (list register))
                                                 (instruction 'save register)
                                                 (element first 2))
                           next)
            (preserving (cdr regs) first next)))))

(define (tack-on head body)
   (instruction-sequence (element head 0)
                         (element head 1)
                         (element head 2)
                         (element body 2)))


(define (parallel-sequences left right))

(define (compile-linkage linkage)
   (cond ((== 'return linkage) (instruction-sequence nil nil
                                                     (instruction 'return)))
         ((== 'next linkage) empty-sequence)
         (else  (instruction-sequence nil nil
                                      (instruction 'goto linkage)))))

(define (compile exp frame target linkage)
   (let (cbegin make-let-bindings)         
      ## make-let-bindings - create and extended enviroment
      ## control-compiler - convert a control-tree structure into a value
      (set cbegin (find-value 'begin controls))
      (set (make-lambda-bindings parameters))
      (set (make-let-bindings bindings))
      (set (needs-register? sequence register)    (member register (element sequence 0)))
      (set (modifies-register? sequence register) (member register (element sequence 1)))
      (set (compile-const value))
      (set (compile-type value))
      (set (compile-global name value))
      (set (compile-choose test on_true on_false))
      (set (compile-first-true first next))
      (set (compile-first-false first next))
      (set (compile-sequence first next))
      (set (compile-make-lambda vars body))           
      (set (compile-apply function args))
      (set (compile-recall label))
      (set (compile-local label value))
      (set (compile-block args)
           (if (nil? args)
                 (const nil)
              (if (nil? (cdr args))
                    (compiler (car args) target linkage)
                 (compile-sequence (compiler (car args) 'void 'next)
                                   (compile-block (cdr args))))))
      (set (control-compiler control args)
           (let (check name)
              (set name (control-name control))
              (set (check symbol) (== symbol name))
              (cond ((check 'define) (compile-global (car args) (car (cdr args))))
                    ((check 'quote)  (compile-const (car args)))
                    ((check 'type)   (compile-type args))
                    ((check 'if)     (compile-choose (compiler (car args) 'test 'next)
                                                     (control-block (car (cdr args)))
                                                     (control-block (cdr (cdr args)))
                    ((check 'unless) (compile-choose (compiler (car args) 'test 'next)
                                                     (compile-block (cdr (cdr args)))
                                                     (compile-block (car (cdr args)))))
                    ((check 'and)    (if (nil? args)
                                           (compile-constant true)
                                        (if (nil? (cdr args))
                                              (compiler (car args) target linkage)
                                           (compile-first-true (compiler (car args))
                                                               (control-compiler control (cdr args))))))
                    ((check 'or)     (if (nil? args)
                                           (compiler-constant nil)
                                        (if (nil? (cdr args))
                                              (compiler (car args) target linkage)
                                           (compile-first-false (compiler (car args))
                                                                (control-compiler control (cdr args))))))
                    ((check 'set)   (compile-local (car args)
                                                   (compiler (car (cdr args)))))
                    ((check 'begin)  (compile-block args)
                    ((check 'lambda) (compile-make-lambda (car args)
                                                          (compiler (cons cbegin (cdr args))
                                                                    'result
                                                                    'return)))
                    ((check 'apply)  (let ((fproc (compiler (car args)))
                                           (vals  (map compiler (car (cdr args)))))
                                        (lambda (env)
                                           (execute (fproc env)
                                                    (map (lambda (aproc) (aproc env)) vals)))))
                    )))
      (cond ((primitive? exp) (compile-constant exp))
            ((control?   exp) (compile-constant exp))
            ((symbol?    exp) (compile-recall exp))
            ((pair?      exp) (control-compiler capply exp)
            ((tuple?     exp) (compile-constant exp))
            ((text?      exp) (compile-constant exp))
            ((integer?   exp) (compile-constant exp))
            ((nil?       exp) (compile-constant exp))
            ((comma?     exp) (error 'COMPILER "comma not supported (yet)" exp))
            ((semi?      exp) (error 'COMPILER "semi not supported (yet)" exp))
            ((block?     exp) (error 'COMPILER "block not supported (yet)" exp))
            (else exp))))

