
(define (constant value)
   (lambda (env) value))

(define (recall name)
   (lambda (env) 
      (let ((value (find-value name env)))
         (if (forced? value)
               (forced-value value)
            value))))

(define (store name value)
   (lambda (env) 
      (update-bindings name (value env) env)))

(define (external name value)
   (lambda (env)
      (global-add name (value env))))

(define (choose test on_true on_false)
   (lambda (env)
      (if (test env)
            (on_true env)
         (on_false env))))

(define (first-true first next)
   (lambda (env)
      (let ((value (first env)))
         (if value
               value
            (next env)))))

(define (first-false first next)
   (lambda (env)
      (let ((value (first env)))
         (if value
               (next env)
            value))))

(define (sequence first next)
   (lambda (env)
      (first env)
      (next env)))

(define (make-lambda vars body))

(define (execute function args)
   (application function args))

(define (evaluator exp env)
   ((analyzer exp) env)))

##
## control-tree -> execution-tree (only-lambdas)
## 
(define (analyzer exp)
   (let (make-let-bindings control-analyzer cbegin)
      ## do-analy           - convert an control-tree argument into a value
      ## make-let-bindings - create and extended enviroment
      ## control-analyzer - convert a control-tree structure into a value
      (set cbegin (find-value 'begin controls))
      (set (make-let-bindings bindings)
           (if (nil? bindings)
                 env
              (let ((entry (car bindings))
                    (tail  (make-let-bindings (cdr bindings))))
                 (cond ((symbol? entry) (cons (cons entry nil) tail))
                       ((pair?  entry) (cons (cons (car entry) 
                                                   (analyzer (car (cdr entry)) env))
                                             tail))
                       ((tuple? entry) (cons (cons (element entry 0)
                                                   (analyzer (element entry 1) env))
                                             tail))))))
      (set (control-analyzer control args)
           (let (check name)
              (set name (control-name control))
              (set (check symbol) (== symbol name))
              (cond ((check 'define) (external (car args) (car (cdr args))))
                    ((check 'quote)  (const (car args)))
                    ((check 'type)   (const (type args)))
                    ((check 'if)     (choose (analyzer (car args))
                                             (analyzer (car (cdr args)))
                                             (control-analyzer cbegin (cdr (cdr args)))))
                    ((check 'unless) (choose (analyzer (car args))
                                             (control-analyzer cbegin (cdr (cdr args)))
                                             (analyzer (car (cdr args)))))
                    ((check 'and)    (if (nil? args)
                                           (constant true)
                                        (if (nil? (cdr args))
                                              (analyzer (car args))
                                           (first-true (analyzer (car args))
                                                       (control-analyzer control (cdr args))))))
                    ((check 'or)     (if (nil? args)
                                           (constant nil)
                                        (if (nil? (cdr args))
                                              (analyzer (car args))
                                           (first-false (analyzer (car args))
                                                        (control-analyzer control (cdr args))))))
                    ((check 'set)   (store (car args)
                                           (analyzer (car (cdr args)))))
                    ((check 'begin)  (if (nil? args)
                                           (const nil)
                                        (if (nil? (cdr args))
                                              (analyzer (car args))
                                           (sequence (analyzer (car args))
                                                     (control-analyzer control (cdr args))))))
                    ((check 'lambda) (make-lambda (car args)
                                                  (analyzer (cons cbegin (cdr args)))))
                    ((check 'apply)  (let ((fproc (analyzer (car args)))
                                           (vals  (map analyzer (car (cdr args)))))
                                        (lambda (env)
                                           (execute (fproc env)
                                                    (map (lambda (aproc) (aproc env)) vals)))))
                    )))
      (cond ((primitive? exp) (constant exp))
            ((control?   exp) (constant exp))
            ((symbol?    exp) (recall exp))
            ((pair?      exp) (control-analyzer capply exp)
            ((tuple?     exp) (constant exp))
            ((text?      exp) (constant exp))
            ((integer?   exp) (constant exp))
            ((nil?       exp) (constant exp))
            ((comma?     exp) (error 'ANALYZER "comma not supported (yet)" exp))
            ((semi?      exp) (error 'ANALYZER "semi not supported (yet)" exp))
            ((block?     exp) (error 'ANALYZER "block not supported (yet)" exp))
            (else exp))))


##
## control-tree -> execution-tree (only-lambdas)
## 
(define (compile exp target linkage)
   (let (make-let-bindings control-compiler cbegin)
      ## do-analy           - convert an control-tree argument into a value
      ## make-let-bindings - create and extended enviroment
      ## control-compiler - convert a control-tree structure into a value
      (set cbegin (find-value 'begin controls))
      (set (make-let-bindings bindings)
           (if (nil? bindings)
                 env
              (let ((entry (car bindings))
                    (tail  (make-let-bindings (cdr bindings))))
                 (cond ((symbol? entry) (cons (cons entry nil) tail))
                       ((pair?  entry) (cons (cons (car entry) 
                                                   (compiler (car (cdr entry)) env))
                                             tail))
                       ((tuple? entry) (cons (cons (element entry 0)
                                                   (compiler (element entry 1) env))
                                             tail))))))
      (set (compile-const value))
      (set (compile-type value))
      (set (compile-reference name value))
      (set (compile-choose test on_true on_false))
      (set (compile-first-true first next))
      (set (compile-first-false first next))
      (set (compile-sequence first next))
      (set (compile-make-lambda vars body))
      (set (compile-apply function args))
      (set (compile-recall label))
      (set (compile-store label value))
      (set (control-compiler control args)
           (let (check name)
              (set name (control-name control))
              (set (check symbol) (== symbol name))
              (cond ((check 'define) (compile-reference (car args) (car (cdr args))))
                    ((check 'quote)  (compile-const (car args)))
                    ((check 'type)   (compile-type args))
                    ((check 'if)     (compile-choose (compiler (car args))
                                                     (compiler (car (cdr args)))
                                                     (control-compiler cbegin (cdr (cdr args)))))
                    ((check 'unless) (compile-choose (compiler (car args))
                                                     (control-compiler cbegin (cdr (cdr args)))
                                                     (compiler (car (cdr args)))))
                    ((check 'and)    (if (nil? args)
                                           (compile-constant true)
                                        (if (nil? (cdr args))
                                              (compiler (car args))
                                           (compile-first-true (compiler (car args))
                                                               (control-compiler control (cdr args))))))
                    ((check 'or)     (if (nil? args)
                                           (compiler-constant nil)
                                        (if (nil? (cdr args))
                                              (compiler (car args))
                                           (compile-first-false (compiler (car args))
                                                                (control-compiler control (cdr args))))))
                    ((check 'set)   (compile-store (car args)
                                                   (compiler (car (cdr args)))))
                    ((check 'begin)  (if (nil? args)
                                           (const nil)
                                        (if (nil? (cdr args))
                                              (compiler (car args))
                                           (compile-sequence (compiler (car args))
                                                             (control-compiler control (cdr args))))))
                    ((check 'lambda) (compile-make-lambda (car args)
                                                          (compiler (cons cbegin (cdr args)))))
                    ((check 'apply)  (let ((fproc (compiler (car args)))
                                           (vals  (map compiler (car (cdr args)))))
                                        (lambda (env)
                                           (execute (fproc env)
                                                    (map (lambda (aproc) (aproc env)) vals)))))
                    )))
      (cond ((primitive? exp) (compile-constant exp))
            ((control?   exp) (compile-constant exp))
            ((symbol?    exp) (compile-recall exp))
            ((pair?      exp) (control-compiler capply exp)
            ((tuple?     exp) (compile-constant exp))
            ((text?      exp) (compile-constant exp))
            ((integer?   exp) (compile-constant exp))
            ((nil?       exp) (compile-constant exp))
            ((comma?     exp) (error 'COMPILER "comma not supported (yet)" exp))
            ((semi?      exp) (error 'COMPILER "semi not supported (yet)" exp))
            ((block?     exp) (error 'COMPILER "block not supported (yet)" exp))
            (else exp))))

