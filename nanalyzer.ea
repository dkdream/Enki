
##
## control-tree -> execution-tree (only-lambdas)
## 
(define (analyzer exp)
   (let (make-let-bindings control-analyzer cbegin)
      (define (constant value)
         (lambda (env) value))
      
      (define (recall name)
         (lambda (env) 
            (let ((value (find-value name env)))
               (if (forced? value)
                     (forced-value value)
                  value))))
      
      (define (store name value)
         (lambda (env) 
            (update-bindings name (value env) env)))
      
      (define (external name value)
         (lambda (env)
            (global-add name (value env))))
      
      (define (choose test on_true on_false)
         (lambda (env)
            (if (test env)
                  (on_true env)
               (on_false env))))
      
      (define (first-true first next)
         (lambda (env)
            (let ((value (first env)))
               (if value
                     value
                  (next env)))))
      
      (define (first-false first next)
         (lambda (env)
            (let ((value (first env)))
               (if value
                     (next env)
                  value))))
      
      (define (sequence first next)
         (lambda (env)
            (first env)
            (next env)))
      
      (define (make-lambda vars body))
      
      (define (execute function args)
         (application function args))
      
      (define (evaluator exp env)
         ((analyzer exp) env)))

      ## do-analy          - convert an control-tree argument into a value
      ## make-let-bindings - create and extended enviroment
      ## control-analyzer  - convert a control-tree structure into a value
      (set cbegin (find-value 'begin controls))
      (set (make-let-bindings bindings)
           (if (nil? bindings)
                 env
              (let ((entry (car bindings))
                    (tail  (make-let-bindings (cdr bindings))))
                 (cond ((symbol? entry) (cons (cons entry nil) tail))
                       ((pair?  entry) (cons (cons (car entry) 
                                                   (analyzer (car (cdr entry)) env))
                                             tail))
                       ((tuple? entry) (cons (cons (element entry 0)
                                                   (analyzer (element entry 1) env))
                                             tail))))))
      (set (control-analyzer control args)
           (let (check name)
              (set name (control-name control))
              (set (check symbol) (== symbol name))
              (cond ((check 'define) (external (car args) (car (cdr args))))
                    ((check 'quote)  (const (car args)))
                    ((check 'type)   (const (type args)))
                    ((check 'if)     (choose (analyzer (car args))
                                             (analyzer (car (cdr args)))
                                             (control-analyzer cbegin (cdr (cdr args)))))
                    ((check 'unless) (choose (analyzer (car args))
                                             (control-analyzer cbegin (cdr (cdr args)))
                                             (analyzer (car (cdr args)))))
                    ((check 'and)    (if (nil? args)
                                           (constant true)
                                        (if (nil? (cdr args))
                                              (analyzer (car args))
                                           (first-true (analyzer (car args))
                                                       (control-analyzer control (cdr args))))))
                    ((check 'or)     (if (nil? args)
                                           (constant nil)
                                        (if (nil? (cdr args))
                                              (analyzer (car args))
                                           (first-false (analyzer (car args))
                                                        (control-analyzer control (cdr args))))))
                    ((check 'set)   (store (car args)
                                           (analyzer (car (cdr args)))))
                    ((check 'begin)  (if (nil? args)
                                           (const nil)
                                        (if (nil? (cdr args))
                                              (analyzer (car args))
                                           (sequence (analyzer (car args))
                                                     (control-analyzer control (cdr args))))))
                    ((check 'lambda) (make-lambda (car args)
                                                  (analyzer (cons cbegin (cdr args)))))
                    ((check 'apply)  (let ((fproc (analyzer (car args)))
                                           (vals  (map analyzer (car (cdr args)))))
                                        (lambda (env)
                                           (execute (fproc env)
                                                    (map (lambda (aproc) (aproc env)) vals)))))
                    )))
      (cond ((primitive? exp) (constant exp))
            ((control?   exp) (constant exp))
            ((symbol?    exp) (recall exp))
            ((pair?      exp) (control-analyzer capply exp)
            ((tuple?     exp) (constant exp))
            ((text?      exp) (constant exp))
            ((integer?   exp) (constant exp))
            ((nil?       exp) (constant exp))
            ((comma?     exp) (error 'ANALYZER "comma not supported (yet)" exp))
            ((semi?      exp) (error 'ANALYZER "semi not supported (yet)" exp))
            ((block?     exp) (error 'ANALYZER "block not supported (yet)" exp))
            (else exp))))

