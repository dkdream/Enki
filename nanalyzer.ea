
(define (constant value)
   (lambda (env) value))

(define (recall name)
   (lambda (env) 
      (let ((value (find-value name env)))
         (if (forced? value)
               (forced-value value)
            value))))

(define (store name value)
   (lambda (env) 
      (update-bindings name (value env) env)))

(define (external name value)
   (lambda (env)
      (global-add name (value env))))

(define (choose test on_true on_false)
   (lambda (env)
      (if (test env)
            (on_true env)
         (on_false env))))

(define (first-true first next)
   (lambda (env)
      (let ((value (first env)))
         (if value
               value
            (next env)))))

(define (first-false first next)
   (lambda (env)
      (let ((value (first env)))
         (if value
               (next env)
            value))))

(define (sequence first next)
   (lambda (env)
      (first env)
      (next env)))

(define (make-lambda vars body))

(define (execute function args)
   (application function args))

(define (evaluator exp env)
   ((analyzer exp) env)))

##
## control-tree -> execution-tree (only-lambdas)
## 
(define (analyzer exp)
   (let (make-let-bindings control-analyzer cbegin)
      ## do-analy           - convert an control-tree argument into a value
      ## make-let-bindings - create and extended enviroment
      ## control-analyzer - convert a control-tree structure into a value
      (set cbegin (find-value 'begin controls))
      (set (make-let-bindings bindings)
           (if (nil? bindings)
                 env
              (let ((entry (car bindings))
                    (tail  (make-let-bindings (cdr bindings))))
                 (cond ((symbol? entry) (cons (cons entry nil) tail))
                       ((pair?  entry) (cons (cons (car entry) 
                                                   (analyzer (car (cdr entry)) env))
                                             tail))
                       ((tuple? entry) (cons (cons (element entry 0)
                                                   (analyzer (element entry 1) env))
                                             tail))))))
      (set (control-analyzer control args)
           (let (check name)
              (set name (control-name control))
              (set (check symbol) (== symbol name))
              (cond ((check 'define) (external (car args) (car (cdr args))))
                    ((check 'quote)  (const (car args)))
                    ((check 'type)   (const (type args)))
                    ((check 'if)     (choose (analyzer (car args))
                                             (analyzer (car (cdr args)))
                                             (control-analyzer cbegin (cdr (cdr args)))))
                    ((check 'unless) (choose (analyzer (car args))
                                             (control-analyzer cbegin (cdr (cdr args)))
                                             (analyzer (car (cdr args)))))
                    ((check 'and)    (if (nil? args)
                                           (constant true)
                                        (if (nil? (cdr args))
                                              (analyzer (car args))
                                           (first-true (analyzer (car args))
                                                       (control-analyzer control (cdr args))))))
                    ((check 'or)     (if (nil? args)
                                           (constant nil)
                                        (if (nil? (cdr args))
                                              (analyzer (car args))
                                           (first-false (analyzer (car args))
                                                        (control-analyzer control (cdr args))))))
                    ((check 'set)   (store (car args)
                                           (analyzer (car (cdr args)))))
                    ((check 'begin)  (if (nil? args)
                                           (const nil)
                                        (if (nil? (cdr args))
                                              (analyzer (car args))
                                           (sequence (analyzer (car args))
                                                     (control-analyzer control (cdr args))))))
                    ((check 'lambda) (make-lambda (car args)
                                                  (analyzer (cons cbegin (cdr args)))))
                    ((check 'apply)  (let ((fproc (analyzer (car args)))
                                           (vals  (map analyzer (car (cdr args)))))
                                        (lambda (env)
                                           (execute (fproc env)
                                                    (map (lambda (aproc) (aproc env)) vals)))))
                    )))
      (cond ((primitive? exp) (constant exp))
            ((control?   exp) (constant exp))
            ((symbol?    exp) (recall exp))
            ((pair?      exp) (control-analyzer capply exp)
            ((tuple?     exp) (constant exp))
            ((text?      exp) (constant exp))
            ((integer?   exp) (constant exp))
            ((nil?       exp) (constant exp))
            ((comma?     exp) (error 'ANALYZER "comma not supported (yet)" exp))
            ((semi?      exp) (error 'ANALYZER "semi not supported (yet)" exp))
            ((block?     exp) (error 'ANALYZER "block not supported (yet)" exp))
            (else exp))))


##
## control-tree -> execution-tree (only-lambdas)
## 
(define (compile exp target linkage)
   (let (make-let-bindings control-compiler cbegin)
      ## make-let-bindings - create and extended enviroment
      ## control-compiler - convert a control-tree structure into a value
      (set cbegin (find-value 'begin controls))
      (set (make-let-bindings bindings)
           (if (nil? bindings)
                 env
              (let ((entry (car bindings))
                    (tail  (make-let-bindings (cdr bindings))))
                 (cond ((symbol? entry) (cons (cons entry nil) tail))
                       ((pair?  entry) (cons (cons (car entry) 
                                                   (compiler (car (cdr entry)) env))
                                             tail))
                       ((tuple? entry) (cons (cons (element entry 0)
                                                   (compiler (element entry 1) env))
                                             tail))))))
      (set (instruction))
      (set (flatten statements)
           (let ((head (car statements))
                 (tail (cdr statements)))
              (if (pair? head)
                    (append (flatten head) (flatten tail))
                 (cons head (flatten tail)))))
      (set (instruction-sequence needs modifies . list)
           (let ((statements (flatten list)))
              (let ((result (tuple needs modifies statements)))
                 (type-of result :icode)
                 result)))
      (set (needs-register? sequence register))
      (set (modifies-register? sequence register))
      (set (union alist blist))
      (set (difference list minus))
      (set empty-sequence (instruction-sequence nil nil))
      (set (append-sequence first next))
      (set (append-preserving registors first next)
           (if (nil? registors)
                 (append-sequence first next)
              (let ((register (car registors)))
                 (if (and (needs-register? first register)
                          (modifies-register? next register))
                       (preserving (cdr regs)
                                   (instruction-sequence (union (list register) (element first 0))
                                                         (difference (element first 1) (list register))
                                                         (instruction 'save register)
                                                         (element first 2))
                                   next)
                    (preserving (cdr regs) first next)))))
      (set (tack-on head body)
           (instruction-sequence (element head 0)
                                 (element head 1)
                                 (element head 2)
                                 (element body 2)))
      (set (parallel-sequences left right) 
           (instruction-sequence (union (element left 0) (element right 0))
      (set (end-with linkage sequence)
           (append-preserving '(continue)
                              sequence
                              (compile-linkage linkage)))
      (set (compile-linkage linkage)
           (cond ((== 'return linkage) (instruction-sequence '(continue)
                                                             nil
                                                             (instruction 'return)))
                 ((== 'next linkage) empty-sequence)
                 (else (instruction-sequence nil nil (instruction 'goto linkage)))))                                        
      (set (compile-const value)
           
           )
      (set (compile-type value))
      (set (compile-global name value))
      (set (compile-choose test on_true on_false))
      (set (compile-first-true first next))
      (set (compile-first-false first next))
      (set (compile-sequence first next))
      (set (compile-make-lambda vars body))
      (set (compile-apply function args))
      (set (compile-recall label))
      (set (compile-local label value))
      (set (control-compiler control args)
           (let (check name)
              (set name (control-name control))
              (set (check symbol) (== symbol name))
              (cond ((check 'define) (compile-global (car args) (car (cdr args))))
                    ((check 'quote)  (compile-const (car args)))
                    ((check 'type)   (compile-type args))
                    ((check 'if)     (compile-choose (compiler (car args))
                                                     (compiler (car (cdr args)))
                                                     (control-compiler cbegin (cdr (cdr args)))))
                    ((check 'unless) (compile-choose (compiler (car args))
                                                     (control-compiler cbegin (cdr (cdr args)))
                                                     (compiler (car (cdr args)))))
                    ((check 'and)    (if (nil? args)
                                           (compile-constant true)
                                        (if (nil? (cdr args))
                                              (compiler (car args))
                                           (compile-first-true (compiler (car args))
                                                               (control-compiler control (cdr args))))))
                    ((check 'or)     (if (nil? args)
                                           (compiler-constant nil)
                                        (if (nil? (cdr args))
                                              (compiler (car args))
                                           (compile-first-false (compiler (car args))
                                                                (control-compiler control (cdr args))))))
                    ((check 'set)   (compile-local (car args)
                                                   (compiler (car (cdr args)))))
                    ((check 'begin)  (if (nil? args)
                                           (const nil)
                                        (if (nil? (cdr args))
                                              (compiler (car args))
                                           (compile-sequence (compiler (car args))
                                                             (control-compiler control (cdr args))))))
                    ((check 'lambda) (compile-make-lambda (car args)
                                                          (compiler (cons cbegin (cdr args)))))
                    ((check 'apply)  (let ((fproc (compiler (car args)))
                                           (vals  (map compiler (car (cdr args)))))
                                        (lambda (env)
                                           (execute (fproc env)
                                                    (map (lambda (aproc) (aproc env)) vals)))))
                    )))
      (cond ((primitive? exp) (compile-constant exp))
            ((control?   exp) (compile-constant exp))
            ((symbol?    exp) (compile-recall exp))
            ((pair?      exp) (control-compiler capply exp)
            ((tuple?     exp) (compile-constant exp))
            ((text?      exp) (compile-constant exp))
            ((integer?   exp) (compile-constant exp))
            ((nil?       exp) (compile-constant exp))
            ((comma?     exp) (error 'COMPILER "comma not supported (yet)" exp))
            ((semi?      exp) (error 'COMPILER "semi not supported (yet)" exp))
            ((block?     exp) (error 'COMPILER "block not supported (yet)" exp))
            (else exp))))

