
(define cadr (lambda (x) (car (cdr x))))
(define cddr (lambda (x) (cdr (cdr x))))

(define concat-list (lambda (x y)
                       (if (pair? x)
                             (cons (car x) (concat-list (cdr x) y))
                          y)))

(define expand-quote
   (let ((qq-list) (qq-element) (qq-object))
      (set qq-list (lambda (l)
                      (if (pair? l)
                            (let ((obj (car l))
                                  (rst (cdr l)))
                               (if (and (pair? obj)
                                        (== (car obj) 'unquote-splicing))
                                     (let ((value (cadr obj)))
                                        (if rst
                                              (list 'concat-list value (qq-list rst))
                                           value))
                                  (list 'cons (qq-object obj) (qq-list rst))))
                         (list 'quote l))))
      (set qq-element (lambda (l)
                         (let ((head (car l)))
                            (if (== head 'unquote)
                                  (cadr l)
                               (qq-list l)))))
      (set qq-object (lambda (object)
                        (if (pair? object)
                              (qq-element object)
                           (list 'quote object))))
      qq-object))

(define quasiquote (form expand-quote))

(define %define-with (lambda (%define)
                        (lambda (pattern . body)
                           (if (pair? pattern)
                                 (let ((name (car pattern))
                                       (args (cdr pattern)))
                                    `(\%define \name (lambda \args \@body)))
                              `(\%define \pattern \@body)))))

(define %define-kind (lambda (%define %kind)
                        (lambda (pattern . body)
                           (if (pair? pattern)
                                 (let ((name (car pattern))
                                       (args (cdr pattern)))
                                    `(\%define \name (\%kind (lambda \args \@body))))
                              `(\%define \pattern (\%kind \@body))))))

(define expand-define (%define-with define))
(define expand-macro  (%define-kind define form))

(define define (form expand-define))
(define macro  (form expand-macro))

(macro (begin . body)
   `(let () \@body))

(define (map-with function list a)
   (let ((action (lambda (val) (function val a))))
      (map action list)))

(define (map2-with function alist blist a)
   (if (pair? alist)
         (let ((head (function (car alist) (car blist) a)))
            (cons head (map2-with function (cdr alist) (cdr blist) a)))))

### let*
(define (expand-let* bindings body)
   (if (pair? (cdr bindings))
         `(let (\(car bindings)) \(expand-let* (cdr bindings) body))
`(let \bindings \@body)))

(macro (let* bindings . body)
   (expand-let* bindings body))

### base.txt

## (begin exp1) -> exp1
## (begin exp1 exp2 ... ) -> ((lambda (x) (begin exp2 ... )) exp1)
(macro (abegin exp . body)
   (if (= nil body)
         exp
      `((lambda (_) (begin \@body)) \exp)))


## (let ([var val] ... ) exp ... ) -> ((lambda (var ... ) (begin exp ...)) val ... )
(macro (alet binding . body) 
   (let ((vars (map car binding))
         (vals (map cdr binding)))
      `((lambda vars \@body) \@vals)))

## (let label ([var val] ... ) exp ... ) -> ((Y (lambda (label var ... ) (begin exp ... ))) val ... )
(macro (ilet label binding . body)
   (let ((vars (map car binding))
         (vals (map cdr binding)))
      `((Y (lambda (\label \@vars) \@body)) \@vals)

## (rec var exp) -> (let ([var '()]) (set! var exp))
(macro (rec var exp)
   `(let ((\var '())) (set \var \exp)))

## (recur f ([var init] ... ) exp ... ) -> ((rec f (lambda (var ... ) (begin exp ... ))) init ... )
(macro (recur name bindings . body)
   (let ((vars (map car binding))
         (vals (map cdr binding)))
      `((rec \name (lambda vars \@body)) \@vals)))

## (when test exp ... ) -> (if test (begin exp ... ) '())
(macro (when test . body)
   `(if \test (begin \@body) '()))

## (unless test exp ... ) -> (if test '() (begin exp ... ))
(macro (unless test . body)
   `(if \test '() \@body))

## (record (var ... ) val exp ... ) -> (apply (lambda (var ... ) (begin exp ... )) val)

#{
## (cond [else exp ... ]) -> (begin exp ... )
## (cond [test exp ... ] clause ... ) -> (if test (begin exp ... ) (cond clause ... ))

(cond (<test> <sequence>)
      <clause 2> ...)
  ==  (if <test>
          (begin <sequence>)
          (cond <clause 2> ...))

(cond (<test>)
      <clause 2> ...)
  ==  (or <test> (cond <clause 2> ...))

(cond (<test> => <recipient>)
      <clause 2> ...)
  ==  (let ((test-result <test>)
            (thunk2 (lambda () <recipient>))
            (thunk3 (lambda () (cond <clause 2> ...))))
        (if test-result
            ((thunk2) test-result)
            (thunk3)))

(cond (else <sequence>))
  ==  (begin <sequence>)

(cond)
  ==  <some expression returning an unspecified value>
}#

(define (expand-cond* clauses))

#{
(case <key>
  ((d1 ...) <sequence>)
  ...)
  ==  (let ((key <key>)
            (thunk1 (lambda () <sequence>))
            ...)
        (cond ((<memv> key '(d1 ...)) (thunk1))
               ...))

(case <key>
  ((d1 ...) <sequence>)
  ...
  (else f1 f2 ...))
  ==  (let ((key <key>)
            (thunk1 (lambda () <sequence>))
            ...
            (elsethunk (lambda () f1 f2 ...)))
        (cond ((<memv> key '(d1 ...)) (thunk1))
               ...
              (else (elsethunk))))
}#

