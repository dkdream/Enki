(require "boot.ea")

(define (double val)    (+ val val))
(define (quadruple val) (double (double val)))

(define (++ x) (+ x 1))
(define (-- x) (- x 1))

(define (reverse list)
   (reverse-inner list nil))

(define (reverse-inner input output)
   (if (pair? input)
         (reverse-inner (cdr input) (cons (car input) output))
      output))

###  Basic Assembly Language Emission

## emit: output a line of assembly by concatenating the strings in an
## arbitrarily nested list structure

(define (asm-display stuff)
   (print stuff))

(define (emit . stuff)
   (asm-display (asm-flatten (cons stuff "\n"))))

(define (asm-flatten stuff)
   (let ((buf (open-buffer)))
      (asm-flatten-inner buf stuff)
      (close-buffer buf)))

(define (asm-flatten-inner buf stuff)
   (if (nil? stuff)
         ""
      (if (pair? stuff)
            (let ()
               (asm-flatten-inner buf (car stuff))
               (asm-flatten-inner buf (cdr stuff)))
         (if (text? stuff)
               (bprint buf stuff)
            (if (integer? stuff)
                  (bprint buf (format "@{s}" stuff))
               (dumpln stuff)
               (error 'flattening "xx"))))))


## Assembly Optimization Tips http://mark.masmcode.com/
## 80x86 instruction set
##      http://www.penguin.cz/~literakl/intel/intel.html
##      http://courses.engr.illinois.edu/ece390/books/labmanual/index.html

## http://www.unixwiz.net/techtips/x86-jumps.html
## AF = adjust flag
## CF = carry flag 
## PF = parity flag 
## ZF = zero flag
## SF = sign flag
## OF = overflow flag
##------
## IF = Interrupt flag
## TF = Trap flag
##------
## DF = Direction flag (used in string ops)

## Emit an indented instruction
(define (insn . insn)
   (emit (cons "        " insn)))

(define (comment . comment)
   (insn "# " comment))

## Emit a two-argument instruction
(define (twoarg mnemonic)
   (lambda (src dest)
      (insn mnemonic " " src ", " dest)))

(define (onearg mnemonic)
   (lambda (rand)
      (insn mnemonic " " rand)))

(define mov     (twoarg "movl"))   ## move 32bit->32bit
(define movb    (twoarg "movb"))   ## move  8bit-> 8bit
(define movzbl  (twoarg "movzbl")) ## move  8bit->32bit (zero-extended)
(define lea     (twoarg "lea"))    ## compute address of
(define add     (twoarg "add"))    ## arth-add    (AF CF OF PF SF ZF)
(define add     (twoarg "adc"))    ## arth-add+CF (AF CF OF PF SF ZF)
(define sub     (twoarg "sub"))    ## arth-sub    (AF CF OF PF SF ZF)
(define sub     (twoarg "sbb"))    ## arth-sub-CF (AF CF OF PF SF ZF)
(define xchg    (twoarg "xchg"))   ## exchange
(define asm-and (twoarg "and"))    ## bitwize and (CF OF PF SF ZF)
(define xor     (twoarg "xor"))    ## bitwize or  (CF OF PF SF ZF)

(define push (onearg "push"))
(define pop  (onearg "pop"))

(define test (twoarg "test"))
# tmp = (argS & argD)
# CF = 0
# OF = 0
# SF = MSB(tmp)
# ZF = (tmp == 0)
# PF = 

(define cmp     (twoarg "cmp"))
# tmp = (argD - argS)
# CF = 0
# OF = 0
# SF = 
# ZF = (tmp == 0)
# PF = 

(define jmp        (onearg "jmp"))
(define jnoverflow (onearg "jno")) ## OF = 0
(define joverflow  (onearg "jo"))  ## OF = 1
(define jnsign     (onearg "jns")) ## SF = 0
(define jsign      (onearg "js"))  ## SF = 1
(define jnzero     (onearg "jnz")) ## ZF = 0
(define jzero      (onearg "jz"))  ## ZF = 1
(define jncarry    (onearg "jnc")) ## CF = 0
(define jcarry     (onearg "jc"))  ## CF = 1
(define jnparity   (onearg "jnp")) ## PF = 0
(define jparity    (onearg "jp"))  ## PF = 1
(define jnabove    (onearg "jna")) ## CF = 1 or ZF = 1
(define jabove     (onearg "ja"))  ## CF = 0 or ZF = 0
(define jnless     (onearg "jnl")) ## SF == OF 
(define jless      (onearg "jl"))  ## SF != OF 
(define jngreater  (onearg "jng")) ## ZF = 1 or SF != OF
(define jgreater   (onearg "jg"))  ## ZF = 1 or SF == OF

(define call (onearg "call"))

(define inc  (onearg "inc"))  ## ++
(define dec  (onearg "dec"))  ## --
(define idiv (onearg "idiv")) ## long divide (EDX:EAX)/xxx (signed)
(define int  (onearg "int"))  ## software interrupt

## These have two-arg forms too, but I'm not using them.
(define sal (onearg "sal")) ## shift-arth-left  (CF OF PF SF ZF) (   CF <- b[n] <- <- b[0] <- 0  )
(define sar (onearg "sar")) ## shift-arth-right (CF OF PF SF ZF) ( b[n] -> b[n] -> -> b[0] -> CF )
(define sar (onearg "shr")) ## shift-log-right  (CF OF PF SF ZF) (    0 -> b[n] -> -> b[0] -> CF )

## Currently only using three zero-argument instructions:
(define (ret)        (insn "ret"))

(define (rep-stosb)  (insn "rep stosb"))  ## Repeat STOS byte (??)
(define (repe-cmpsb) (insn "repe cmpsb")) ## Repeat CMPS byte (??)

(define (save)       (insn "pusha")) ## push all registers 
(define (restore)    (insn "popa"))  ## pop all registers

## Registers:
(define eax "%eax") ## scratch bottom-of-frame return-value
(define ebx "%ebx") ## scratch                             (gcc-callee-saved)
(define ecx "%ecx") ## scratch
(define edx "%edx") ## scratch
(define ebp "%ebp") ## frame-pointer   (enki-callee-saved) (gcc-callee-saved)
(define esp "%esp") ## top of stack    (enki-callee-saved) (gcc-callee-saved)
(define esi "%esi") ## bottom of stack (enki-callee-saved) (gcc-callee-saved)
(define edi "%edi") ## scratch                             (gcc-callee-saved)
(define al  "%al")  ## low-byte of eax

(define frame ebp)
(define bos   esi)
(define tos   esp)
(define scr   edi)

## x86 addressing modes:
(define (const x)         (list "$" x))
(define (indirect x)      (list "(" x ")"))
(define (offset x offset) (list offset (indirect x)))
(define (absolute x)      (list "*" x))

(define (arg index) 
   (offset frame (* -4 (++ index))))

(define (lcl index) 
   (offset bos (* -4 (++ index))))

(define (drop count)
   (let ((size (* 4 count)))
      (add (const size) tos)))

## Use this one inside of "indirect" or "offset".
(define (index-register base index size)
   (list base "," index "," size))

(define (syscall) (int (const "0x80")))

## Other stuff for basic asm emission.
(define (section name) (insn ".section " name))
(define (rodata)       (section ".rodata"))
(define (text)         (insn ".text"))
(define (label label)  (emit label ":"))

## define a .globl label
(define (global-label lbl)
   (insn ".globl " lbl)
   (label lbl))

(define label-index-counter 0)
(define label-prefix        "K")
(define (new-label)
   (define label-index-counter (++ label-index-counter))
   (list label-prefix "_" (format "@{s}" label-index-counter)))

#thom# string need to be converted to a c-string
(define (asm-represent-string string) 
   (list "\"" string "\""))

(define (ascii string) 
   (insn ".ascii " (asm-represent-string string)))

## emit a prologue for a datum to be assembled into .rodata
(define (rodatum labelname)
   (rodata)
   (comment "align pointers so they end in binary 00")
   (insn ".align 4")
   (label labelname))

## index is zero-based
(define (get-function-arg index reg)
   (mov (offset frame (quadruple (++index))) reg))

## index is zero-based
(define (set-function-arg index reg)
   (mov reg (offset frame (quadruple (++index)))))

(define (compile-word contents) 
   (insn ".long " contents))

(define (compile-apply      nargs)) 
(define (compile-tail-apply nargs))

(define (compile-function-prologue)
   (xchg eax tos)  ## exchange top-of-stack and bottom-of-frame
   (push frame)    ## push old frame
   (push bos)      ## push old bottom-of-stack
   (mov eax frame) ## set new frame
   (mov tos bos))  ## set new  bottom-of-stack

(define (compile-function-epilogue)
   (mov frame scr)  ## mov the frame(old-tos) to scr
   (mov bos tos)    ## clear stack/locals
   (pop bos)        ## pop the old bottom-of-stack
   (pop frame)      ## pop the old frame
   (mov scr tos)    ## set old top-of-stack
   (ret))

(define (compile-function bodylabel nargs nlcls body)
   (text)
   (insn ".align 4")
   (insn ".type " bodylabel ", @function")  ## may not be needed
   (global-label bodylabel)
   (compile-function-prologue)
   (if (< 0 nlcls)
         (sub (const (* 4 nlcls)) tos))
   (body)
   (compile-function-epilogue)
   (insn ".size " bodylabel ", .-" bodylabel)) ## may not be needed

(define (compile-c-call function nargs))




