(require "boot.ea")

(define (double val)    (+ val val))
(define (quadruple val) (double (double val)))

(define (++ x) (+ x 1))
(define (-- x) (- x 1))

(define (reverse list)
   (reverse-inner list nil))

(define (reverse-inner input output)
   (if (pair? input)
         (reverse-inner (cdr input) (cons (car input) output))
      output))

###  Basic Assembly Language Emission

## emit: output a line of assembly by concatenating the strings in an
## arbitrarily nested list structure

(define assembly-diversions nil)
(define diverted-assembly   nil)

(define (asm-display stuff)
   (if assembly-diversions
         (set diverted-assembly (cons stuff diverted-assembly))
      (print stuff)))

(define (push-assembly-diversion)
   (assert (not assembly-diversions) "already diverted")
   (set assembly-diversions true))

(define (pop-diverted-assembly)
   (let ((result (asm-flatten (reverse diverted-assembly))))
      (set assembly-diversions nil)
      (set diverted-assembly nil)
      result))

(define (emit . stuff)
   (asm-display (asm-flatten (cons stuff "\n"))))

(define (asm-flatten stuff)
   (let ((buf (open-buffer)))
      (asm-flatten-inner buf stuff)
      (close-buffer buf)))

(define (asm-flatten-inner buf stuff)
   (if (nil? stuff)
         nil
      (if (pair? stuff)
            (let ()
               (asm-flatten-inner buf (car stuff))
               (asm-flatten-inner buf (cdr stuff)))
         (if (text? stuff)
               (bprint buf stuff)
            (if (integer? stuff)
                  (bprint buf (format "@{s}" stuff))
               (dumpln stuff)
               (error 'flattening "xx"))))))


## Emit an indented instruction
(define (insn . insn)
   (emit (cons "        " insn)))

(define (comment . comment)
   (insn "# " comment))

## Emit a two-argument instruction
(define (twoarg mnemonic)
   (lambda (src dest)
      (insn mnemonic " " src ", " dest)))

## For example:
(define mov     (twoarg "movl"))
(define movb    (twoarg "movb"))
(define movzbl  (twoarg "movzbl"))
(define test    (twoarg "test"))
(define cmp     (twoarg "cmpl"))
(define lea     (twoarg "lea"))
(define add     (twoarg "add"))
(define sub     (twoarg "sub"))
(define xchg    (twoarg "xchg"))
(define asm-and (twoarg "and"))
(define xor     (twoarg "xor"))

## Emit a one-argument instruction
(define (onearg mnemonic)
   (lambda (rand)
      (insn mnemonic " " rand)))

(define push      (onearg "push"))
(define pop       (onearg "pop"))
(define jmp       (onearg "jmp"))
(define jnz       (onearg "jnz"))
(define je        (onearg "je"))
(define jz je)
(define jnb       (onearg "jnb"))
(define jl        (onearg "jl"))
(define js        (onearg "js"))
(define ja        (onearg "ja"))
(define call      (onearg "call"))
(define int       (onearg "int"))
(define inc       (onearg "inc"))
(define dec       (onearg "dec"))
(define idiv      (onearg "idiv"))

## These have two-arg forms too, but I'm not using them.
(define sal (onearg "sal"))
(define sar (onearg "sar"))

## Currently only using three zero-argument instructions:
(define (ret)        (insn "ret"))
(define (rep-stosb)  (insn "rep stosb"))
(define (repe-cmpsb) (insn "repe cmpsb"))

## Registers:
(define eax "%eax") ## bottom of frame/return-value/scratch
(define ebx "%ebx") ## scratch                             (gcc-callee-saved)
(define ecx "%ecx") ## scratch
(define edx "%edx") ## scratch
(define ebp "%ebp") ## frame-pointer   (enki-callee-saved) (gcc-callee-saved)
(define esp "%esp") ## top of stack    (enki-callee-saved) (gcc-callee-saved)
(define esi "%esi") ## bottom of stack (enki-callee-saved) (gcc-callee-saved)
(define edi "%edi") ## scratch                             (gcc-callee-saved)
(define al  "%al")

(define frame ebp)
(define bos   esi)
(define tos   esp)
(define scr   edi)

## x86 addressing modes:
(define (const x)         (list "$" x))
(define (indirect x)      (list "(" x ")"))
(define (offset x offset) (list offset (indirect x)))
(define (absolute x)      (list "*" x))

(define (arg index) 
   (offset frame (* -1 index)))

(define (drop count)
   (let ((offset (* -4 count)))
      (sub (const offset) tos)))

## Use this one inside of "indirect" or "offset".
(define (index-register base index size)
   (list base "," index "," size))

(define (syscall) (int (const "0x80")))

## Other stuff for basic asm emission.
(define (section name) (insn ".section " name))
(define (rodata)       (section ".rodata"))
(define (text)         (insn ".text"))
(define (label label)  (emit label ":"))

## define a .globl label
(define (global-label lbl)
   (insn ".globl " lbl)
   (label lbl))

(define label-index-counter 0)
(define label-prefix        "K")
(define (new-label)
   (define label-index-counter (++ label-index-counter))
   (list label-prefix "_" (format "@{s}" label-index-counter)))

#thom# string need to be converted to a c-string
(define (asm-represent-string string) 
   (list "\"" string "\""))

(define (ascii string) 
   (insn ".ascii " (asm-represent-string string)))

## emit a prologue for a datum to be assembled into .rodata
(define (rodatum labelname)
   (rodata)
   (comment "align pointers so they end in binary 00")
   (insn ".align 4")
   (label labelname))

## index is zero-based
(define (get-function-arg index reg)
   (mov (offset frame (quadruple (++index))) reg))

## index is zero-based
(define (set-function-arg index reg)
   (mov reg (offset frame (quadruple (++index)))))

(define (compile-word contents) 
   (insn ".long " contents))

(define (compile-apply      nargs)) 
(define (compile-tail-apply nargs))

(define (compile-function-prologue)
   (xchg eax tos)  ## exchange top-of-stack and bottom-of-frame
   (push frame)    ## push old frame
   (push bos)      ## push old bottom-of-stack
   (mov eax frame) ## set new frame
   (mov tos bos))  ## set new  bottom-of-stack

(define (compile-function-epilogue)
   (mov frame scr)  ## mov the frame(old-tos) to scr
   (mov bos tos)    ## clear stack/locals
   (pop bos)        ## pop the old bottom-of-stack
   (pop frame)      ## pop the old frame
   (mov scr tos)    ## set old top-of-stack
   (ret))

(define (compile-function bodylabel nargs body)
   (text)
   (insn ".align 4")
   (insn ".type " bodylabel ", @function")  ## may not be needed
   (label bodylabel)
   (compile-function-prologue)
   (body)
   (compile-function-epilogue)
   (insn ".size " bodylabel ", .-" bodylabel)) ## may not be needed

(define (compile-c-call function nargs))




