(require "boot.ea")

(define (double val)    (+ val val))
(define (quadruple val) (double (double val)))

(define (++ x) (+ x 1))
(define (-- x) (- x 1))

(define (reverse list)
   (reverse-inner list nil))

(define (reverse-inner input output)
   (if (pair? input)
         (reverse-inner (cdr input) (cons (car input) output))
      output))

###  Basic Assembly Language Emission

## emit: output a line of assembly by concatenating the strings in an
## arbitrarily nested list structure

(define (asm-display stuff)
   (print stuff))

(define (emit . stuff)
   (asm-display (asm-flatten (cons stuff "\n"))))

(define (asm-flatten stuff)
   (let ((buf (open-buffer)))
      (asm-flatten-inner buf stuff)
      (close-buffer buf)))

(define (asm-flatten-inner buf stuff)
   (if (nil? stuff)
         ""
      (if (pair? stuff)
            (let ()
               (asm-flatten-inner buf (car stuff))
               (asm-flatten-inner buf (cdr stuff)))
         (if (text? stuff)
               (bprint buf stuff)
            (if (integer? stuff)
                  (bprint buf (format "@{s}" stuff))
               (dumpln stuff)
               (error 'flattening "xx"))))))


## Emit an indented instruction
(define (insn . insn)
   (emit (cons "        " insn)))

(define (comment . comment)
   (insn "# " comment))

## Emit a two-argument instruction
(define (twoarg mnemonic)
   (lambda (src dest)
      (insn mnemonic " " src ", " dest)))

(define (onearg mnemonic)
   (lambda (rand)
      (insn mnemonic " " rand)))

(define mov     (twoarg "movl"))
(define movb    (twoarg "movb"))
(define movzbl  (twoarg "movzbl"))
(define lea     (twoarg "lea"))
(define add     (twoarg "add")) 
(define sub     (twoarg "sub"))
(define xchg    (twoarg "xchg"))
(define asm-and (twoarg "and"))
(define xor     (twoarg "xor"))

(define push       (onearg "push"))
(define pop        (onearg "pop"))

## Assembly Optimization Tips http://mark.masmcode.com/

## http://www.unixwiz.net/techtips/x86-jumps.html
## AF = adjust flag
## CF = carry flag 
## PF = parity flag 
## ZF = zero flag
## SF = sign flag
## OF = overflow flag

(define test    (twoarg "test"))
# CF = 0, OF = 0
# tmp = (argS & argD)
# SF = MSB(tmp)
# ZF = (tmp == 0)
# PF = 

(define cmp     (twoarg "cmp"))
# tmp = (argD - argS)

(define jmp        (onearg "jmp"))
(define jnoverflow (onearg "jno")) ## OF = 0
(define joverflow  (onearg "jo"))  ## OF = 1
(define jnsign     (onearg "jns")) ## SF = 0
(define jsign      (onearg "js"))  ## SF = 1
(define jnzero     (onearg "jnz")) ## ZF = 0
(define jzero      (onearg "jz"))  ## ZF = 1
(define jncarry    (onearg "jnc")) ## CF = 0
(define jcarry     (onearg "jc"))  ## CF = 1
(define jnparity   (onearg "jnp")) ## PF = 0
(define jparity    (onearg "jp"))  ## PF = 1
(define jnabove    (onearg "jna")) ## CF = 1 or ZF = 1
(define jabove     (onearg "ja"))  ## CF = 0 or ZF = 0
(define jnless     (onearg "jnl")) ## SF == OF 
(define jless      (onearg "jl"))  ## SF != OF 
(define jngreater  (onearg "jng")) ## ZF = 1 or SF != OF
(define jgreater   (onearg "jg"))  ## ZF = 1 or SF == OF

(define inc  (onearg "inc")) ## ++
(define dec  (onearg "dec")) ## --
(define call (onearg "call"))
(define idiv (onearg "idiv")) ## long divide (EDX:EAX)/xxx (signed)
(define int  (onearg "int")) ## software interrupt

## These have two-arg forms too, but I'm not using them.
(define sal (onearg "sal"))
(define sar (onearg "sar"))

## Currently only using three zero-argument instructions:
(define (ret)        (insn "ret"))

(define (rep-stosb)  (insn "rep stosb"))  ## Repeat STOS byte
(define (repe-cmpsb) (insn "repe cmpsb")) ## Repeat 

(define (save)       (insn "pusha"))
(define (restore)    (insn "popa"))

## Registers:
(define eax "%eax") ## bottom of frame/return-value/scratch
(define ebx "%ebx") ## scratch                             (gcc-callee-saved)
(define ecx "%ecx") ## scratch
(define edx "%edx") ## scratch
(define ebp "%ebp") ## frame-pointer   (enki-callee-saved) (gcc-callee-saved)
(define esp "%esp") ## top of stack    (enki-callee-saved) (gcc-callee-saved)
(define esi "%esi") ## bottom of stack (enki-callee-saved) (gcc-callee-saved)
(define edi "%edi") ## scratch                             (gcc-callee-saved)
(define al  "%al")

(define frame ebp)
(define bos   esi)
(define tos   esp)
(define scr   edi)

## x86 addressing modes:
(define (const x)         (list "$" x))
(define (indirect x)      (list "(" x ")"))
(define (offset x offset) (list offset (indirect x)))
(define (absolute x)      (list "*" x))

(define (arg index) 
   (offset frame (* -4 (++ index))))

(define (lcl index) 
   (offset bos (* -4 (++ index))))

(define (drop count)
   (let ((size (* 4 count)))
      (add (const size) tos)))

## Use this one inside of "indirect" or "offset".
(define (index-register base index size)
   (list base "," index "," size))

(define (syscall) (int (const "0x80")))

## Other stuff for basic asm emission.
(define (section name) (insn ".section " name))
(define (rodata)       (section ".rodata"))
(define (text)         (insn ".text"))
(define (label label)  (emit label ":"))

## define a .globl label
(define (global-label lbl)
   (insn ".globl " lbl)
   (label lbl))

(define label-index-counter 0)
(define label-prefix        "K")
(define (new-label)
   (define label-index-counter (++ label-index-counter))
   (list label-prefix "_" (format "@{s}" label-index-counter)))

#thom# string need to be converted to a c-string
(define (asm-represent-string string) 
   (list "\"" string "\""))

(define (ascii string) 
   (insn ".ascii " (asm-represent-string string)))

## emit a prologue for a datum to be assembled into .rodata
(define (rodatum labelname)
   (rodata)
   (comment "align pointers so they end in binary 00")
   (insn ".align 4")
   (label labelname))

## index is zero-based
(define (get-function-arg index reg)
   (mov (offset frame (quadruple (++index))) reg))

## index is zero-based
(define (set-function-arg index reg)
   (mov reg (offset frame (quadruple (++index)))))

(define (compile-word contents) 
   (insn ".long " contents))

(define (compile-apply      nargs)) 
(define (compile-tail-apply nargs))

(define (compile-function-prologue)
   (xchg eax tos)  ## exchange top-of-stack and bottom-of-frame
   (push frame)    ## push old frame
   (push bos)      ## push old bottom-of-stack
   (mov eax frame) ## set new frame
   (mov tos bos))  ## set new  bottom-of-stack

(define (compile-function-epilogue)
   (mov frame scr)  ## mov the frame(old-tos) to scr
   (mov bos tos)    ## clear stack/locals
   (pop bos)        ## pop the old bottom-of-stack
   (pop frame)      ## pop the old frame
   (mov scr tos)    ## set old top-of-stack
   (ret))

(define (compile-function bodylabel nargs nlcls body)
   (text)
   (insn ".align 4")
   (insn ".type " bodylabel ", @function")  ## may not be needed
   (global-label bodylabel)
   (compile-function-prologue)
   (if (< 0 nlcls)
         (sub (const (* 4 nlcls)) tos))
   (body)
   (compile-function-epilogue)
   (insn ".size " bodylabel ", .-" bodylabel)) ## may not be needed

(define (compile-c-call function nargs))




