(require "boot.ea")

(define (double val)    (+ val val))
(define (quadruple val) (double (double val)))

(define (++ x) (+ x 1))
(define (-- x) (- x 1))

(define (reverse list)
   (reverse-inner list nil))

(define (reverse-inner input output)
   (if (pair? input)
         (reverse-inner (cdr input) (cons (car input) output))
      output))

###  Basic Assembly Language Emission

## emit: output a line of assembly by concatenating the strings in an
## arbitrarily nested list structure

(define (asm-display stuff)
   (print stuff))

(define (emit . stuff)
   (asm-display (asm-flatten (cons stuff "\n"))))

(define (asm-flatten stuff)
   (let ((buf (open-buffer)))
      (asm-flatten-inner buf stuff)
      (close-buffer buf)))

(define (asm-flatten-inner buf stuff)
   (if (nil? stuff)
         ""
      (if (pair? stuff)
            (let ()
               (asm-flatten-inner buf (car stuff))
               (asm-flatten-inner buf (cdr stuff)))
         (if (text? stuff)
               (bprint buf stuff)
            (if (integer? stuff)
                  (bprint buf (format "@{s}" stuff))
               (dumpln stuff)
               (errore 'flattening "xx"))))))


## Assembly Optimization Tips http://mark.masmcode.com/
## 80x86 instruction set
##      http://www.penguin.cz/~literakl/intel/intel.html
##      http://courses.engr.illinois.edu/ece390/books/labmanual/index.html

## http://www.unixwiz.net/techtips/x86-jumps.html
## AF = adjust flag
## CF = carry flag 
## PF = parity flag 
## ZF = zero flag
## SF = sign flag
## OF = overflow flag
##------
## IF = Interrupt flag
## TF = Trap flag
##------
## DF = Direction flag (used in string ops)

## Emit an indented instruction
(define (insn . insn)
   (emit (cons "        " insn)))

(define (comment . comment)
   (insn "# " comment))

## Emit a two-argument instruction
(define (twoarg mnemonic)
   (lambda (src dest)
      (insn mnemonic " " src ", " dest)))

(define (onearg mnemonic)
   (lambda (rand)
      (insn mnemonic " " rand)))

(define mov     (twoarg "movl"))   ## move 32bit->32bit
(define movb    (twoarg "movb"))   ## move  8bit-> 8bit
(define movzbl  (twoarg "movzbl")) ## move  8bit->32bit (zero-extended)
(define lea     (twoarg "lea"))    ## compute address of
(define add     (twoarg "add"))    ## arth-add    (AF CF OF PF SF ZF)
(define adc     (twoarg "adc"))    ## arth-add+CF (AF CF OF PF SF ZF)
(define sub     (twoarg "sub"))    ## arth-sub    (AF CF OF PF SF ZF)
(define sub     (twoarg "sbb"))    ## arth-sub-CF (AF CF OF PF SF ZF)
(define xchg    (twoarg "xchg"))   ## exchange
(define asm-and (twoarg "and"))    ## bitwize and (CF OF PF SF ZF)
(define xor     (twoarg "xor"))    ## bitwize or  (CF OF PF SF ZF)
(define imul    (twoarg "imul"))

(define push (onearg "push"))
(define pop  (onearg "pop"))

(define test (twoarg "test"))
# tmp = (argS & argD)
# CF  = 0
# OF  = 0
# SF  = MSBit(tmp)
# ZF  = (tmp == 0)
# PF  = even(bit-count(tmp))

(define cmp (twoarg "cmp"))
# tmp = (argD - argS)
# CF  = bit-count(argD - argS) > bit-count(tmp)
# OF  = MSBit(argD) != MSBit(tmp)
# SF  = MSBit(tmp)
# ZF  = (tmp == 0)
# PF  = even(bit-count(tmp))

(define jmp        (onearg "jmp"))
(define jnoverflow (onearg "jno")) ## OF = 0
(define joverflow  (onearg "jo"))  ## OF = 1
(define jnsign     (onearg "jns")) ## SF = 0
(define jsign      (onearg "js"))  ## SF = 1
(define jnzero     (onearg "jnz")) ## ZF = 0
(define jzero      (onearg "jz"))  ## ZF = 1
(define jncarry    (onearg "jnc")) ## CF = 0
(define jcarry     (onearg "jc"))  ## CF = 1
(define jnparity   (onearg "jnp")) ## PF = 0
(define jparity    (onearg "jp"))  ## PF = 1
(define jnabove    (onearg "jna")) ## CF = 1 or ZF = 1
(define jabove     (onearg "ja"))  ## CF = 0 or ZF = 0
(define jnless     (onearg "jnl")) ## SF == OF 
(define jless      (onearg "jl"))  ## SF != OF 
(define jngreater  (onearg "jng")) ## ZF = 1 or SF != OF
(define jgreater   (onearg "jg"))  ## ZF = 1 or SF == OF

(define call (onearg "call"))

(define inc  (onearg "inc"))  ## ++
(define dec  (onearg "dec"))  ## --
(define idiv (onearg "idiv")) ## long divide (EDX:EAX)/xxx (signed)
(define int  (onearg "int"))  ## software interrupt
(define mul  (onearg "mull")) ##


## These have two-arg forms too, but I'm not using them.
(define sal (onearg "sal")) ## shift-arth-left  (CF OF PF SF ZF) (   CF <- b[n] <- <- b[0] <- 0  )
(define sar (onearg "sar")) ## shift-arth-right (CF OF PF SF ZF) ( b[n] -> b[n] -> -> b[0] -> CF )
(define sar (onearg "shr")) ## shift-log-right  (CF OF PF SF ZF) (    0 -> b[n] -> -> b[0] -> CF )

## Currently only using three zero-argument instructions:
(define (ret)        (insn "ret"))

(define (rep-stosb)  (insn "rep stosb"))  ## Repeat STOS byte (??)
(define (repe-cmpsb) (insn "repe cmpsb")) ## Repeat CMPS byte (??)

(define (save)       (insn "pusha")) ## push all registers 
(define (restore)    (insn "popa"))  ## pop all registers

## Registers:
(define eax "%eax") ## scratch    (bottom-of-frame|return-value)
(define ebx "%ebx") ## scratch                             (gcc-callee-saved)
(define ecx "%ecx") ## scratch
(define edx "%edx") ## scratch
(define ebp "%ebp") ## frame-pointer   (enki-callee-saved) (gcc-callee-saved)
(define esp "%esp") ## top of stack    (enki-callee-saved) (gcc-callee-saved)
(define esi "%esi") ## bottom of stack (enki-callee-saved) (gcc-callee-saved)
(define edi "%edi") ## scratch                             (gcc-callee-saved)
(define al  "%al")  ## low-byte of eax

## edx:eax = long-long accumulater
## ebx:ecx = long-long argument
## edi     = 

(define frame ebp)
(define bos   esi)
(define tos   esp)
(define scr   edi)

## x86 addressing modes:
(define (const x)         (list "$" x))
(define (indirect x)      (list "(" x ")"))
(define (offset x offset) (list offset (indirect x)))
(define (absolute x)      (list "*" x))

## Use this one inside of "indirect" or "offset".
(define (index-register base index size)
   (list base "," index "," size))

(define (arg index) 
   (offset frame (* -4 (++ index))))

(define (lcl index) 
   (offset bos (* -4 (++ index))))

(define (drop count)
   (let ((size (* 4 count)))
      (add (const size) tos)))

(define (syscall) (int (const "0x80")))

## Other stuff for basic asm emission.
(define (section name) (insn ".section " name))
(define (rodata)       (section ".rodata"))
(define (text)         (insn ".text"))
(define (label label)  (emit label ":"))

## define a .globl label
(define (global-label lbl)
   (insn ".globl " lbl)
   (label lbl))

(define label-index-counter 0)
(define label-prefix        "K")
(define (new-label)
   (define label-index-counter (++ label-index-counter))
   (list label-prefix "_" (format "@{s}" label-index-counter)))

#thom# string need to be converted to a c-string
(define (asm-represent-string string) 
   (list "\"" string "\""))

(define (ascii string) 
   (insn ".ascii " (asm-represent-string string)))

## emit a prologue for a datum to be assembled into .rodata
(define (rodatum labelname)
   (rodata)
   (comment "align pointers so they end in binary 00")
   (insn ".align " (sizeof 'pointer))
   (label labelname))

## index is zero-based
(define (get-function-arg index reg)
   (mov (offset frame (quadruple (++index))) reg))

## index is zero-based
(define (set-function-arg index reg)
   (mov reg (offset frame (quadruple (++index)))))

(define (compile-word contents) 
   (insn ".long " contents))

(define (compile-apply      nargs)) 
(define (compile-tail-apply nargs))

(define (compile-function-prologue)
   (xchg eax tos)  ## exchange top-of-stack and bottom-of-frame
   (push frame)    ## push old frame
   (push bos)      ## push old bottom-of-stack
   (mov eax frame) ## set new frame
   (mov tos bos))  ## set new  bottom-of-stack

(define (compile-tail label count))
(define (compile-call label count))

(define (compile-function-epilogue)
   (mov frame scr)  ## mov the frame(old-tos) to scr
   (mov bos tos)    ## clear stack/locals
   (pop bos)        ## pop the old bottom-of-stack
   (pop frame)      ## pop the old frame
   (mov scr tos)    ## set old top-of-stack
   (ret))

(define (compile-function bodylabel nargs nlcls body)
   (text)
   (insn ".align " (sizeof 'pointer))
   (insn ".type " bodylabel ", @function")  ## may not be needed
   (global-label bodylabel)
   (compile-function-prologue)
   (if (< 0 nlcls)
         (sub (const (* 4 nlcls)) tos))
   (body)
   (compile-function-epilogue)
   (insn ".size " bodylabel ", .-" bodylabel)) ## may not be needed

(define (compile-c-call function . args)
   (let ((count  (length args))
         (pushit))
      (set pushit (lambda (list)
                     (if (pair? list)
                           (begin 
                              (pushit (cdr list))
                              (push (car list))))))
      (if count
            (begin 
               (pushit args)
               (call function)
               (drop count))
         (call function))))

(define (compile-load-acc node)
   (lea node edi)
   (mov (indirect edi) eax)
   (mov (offset edi 4) edx))

(define (compile-add-acc node)
   (lea node edi)
   (mov (indirect edi) ecx)
   (mov (offset edi 4) ebx)
   (add ecx eax)
   (adc ebx edx))

(define (compile-sub-acc node)
   (lea node edi)
   (mov (indirect edi) ecx)
   (mov (offset edi 4) ebx)
   (sub ecx eax)
   (sbb ebx edx))

(define (compile-mul-acc node)
   (lea node edi)
   (mov (indirect edi) ecx)
   (mov (offset edi 4) ebx)
   (push bos)
   (mov  ebx esi)
   (imul eax esi) ## high-l * low-r
   (mov  edx edi)
   (imul ecx edi) ## low-l * high-r
   (add  edi esi)
   (mul  ecx)
   (add  edi esi)
   (mov  esi edx)
   (pop bos))

(define (compile-store-acc node)
   (lea node edi)
   (mov eax (indirect edi))
   (mov ebx (offset edi 4)))


### (code from Sicp/ch5-compiler.scm)

(define (self-evaluating? exp) nil)
(define (quoted? exp) nil)
(define (variable? exp) nil)
(define (assignment? exp) nil)
(define (definition? exp) nil)
(define (definition? exp) nil)
(define (if? exp) nil)
(define (lambda? exp) nil)
(define (begin? exp) nil)
(define (cond? exp) nil)
(define (application? exp) nil)

##
## analyze is modelled after eval
##

(define (analyze exp)
   (cond ((self-evaluating? exp) (analyze-self-evaluating exp))
         ((quoted? exp)          (analyze-quoted exp))
         ((variable? exp)        (analyze-variable exp))
         ((assignment? exp)      (analyze-assignment exp))
         ((definition? exp)      (analyze-definition exp))
         ((if? exp)              (analyze-if exp))
         ((lambda? exp)          (analyze-lambda exp))
         ((let? exp)             (analyze-let exp))
         ((begin? exp)           (analyze-sequence (begin-actions exp)))
         ((application? exp)     (analyze-application exp))
         (else
          (error 'unknown "Unknown expression type -- ANALYZE" exp))))

## (compile <expression>
##          <target-location>
##          <linkage-descriptor 'continue 'return '(jump <label>) '(call <label> <count>) '(tail <label> <count>)>
##          <free-registers>)
##
## compile is modelled after eval
##
## example:
##    (compile 5 (register 'eax) 'continue '(eax))  == (mov (cont 5) eax)
##    (compile 5 (register 'result) 'return '(eax)) == (begin (mov (cont 5) eax) (compile-function-epilogue))
##    (compile 5 (local 1) '(jump endif5) '(eax))   == (begin (mov (cont 5) eax) (mv eax (local 1)) (jmp 'endif5))
##    (compile 5 'push '(call add 2) '(eax))        == (begin (mov (cont 5) eax) (push eax) (compile-call 'add 3))
##    (compile 5 'push '(call add 2) '(eax))        == (begin (mov (cont 5) eax) (push eax) (compile-tail 'add 3))

(define (compile exp target linkage free)
   (cond ((self-evaluating? exp) (compile-self-evaluating exp target linkage free))
         ((quoted? exp)          (compile-quoted exp target linkage free))
         ((variable? exp)        (compile-variable exp target linkage free))
         ((assignment? exp)      (compile-assignment exp target linkage free))
         ((definition? exp)      (compile-definition exp target linkage free))
         ((if? exp)              (compile-if exp target linkage free))
         ((lambda? exp)          (compile-lambda exp target linkage free))
         ((let? exp)          (compile-let exp target linkage free))
         ((begin? exp)           (compile-sequence (begin-actions exp) target linkage free))
         ((application? exp)     (compile-application exp target linkage free))
         (else
          (error 'unknown "Unknown expression type -- COMPILE" exp))))



