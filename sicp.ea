
##
##  CHAPTER 4 OF STRUCTURE AND INTERPRETATION OF COMPUTER PROGRAMS
##
(define (ch4-eval exp env)
   (cond ((self-evaluating? exp) exp)
         ((variable?    exp) (lookup-variable-value exp env))
         ((quoted?      exp) (text-of-quotation exp))
         ((assignment?  exp) (eval-assignment exp env))
         ((definition?  exp) (eval-definition exp env))
         ((if?          exp) (eval-if exp env))
         ((lambda?      exp) (make-procedure (lambda-parameters exp) (lambda-body exp) env))
         ((begin?       exp) (eval-sequence (begin-actions exp) env))
         ((cond?        exp) (ch4-eval (cond->if exp) env))
         ((application? exp) (ch4-apply (ch4-eval (operator exp) env) (list-of-values (operands exp) env)))
         (else (error 'EVAL exp))))


(define (ch4-apply procedure arguments)
  (cond ((primitive-procedure? procedure) (apply-primitive-procedure procedure arguments))
        ((compound-procedure?  procedure) (eval-sequence (procedure-body procedure) (extend-environment (procedure-parameters procedure) arguments (procedure-environment procedure))))
        (else (error 'APPLY procedure))))

(define (ch4-analyze exp)
  (cond ((self-evaluating? exp) (analyze-self-evaluating exp))
        ((quoted?      exp) (analyze-quoted exp))
        ((variable?    exp) (analyze-variable exp))
        ((assignment?  exp) (analyze-assignment exp))
        ((definition?  exp) (analyze-definition exp))
        ((if?          exp) (analyze-if exp))
        ((lambda?      exp) (analyze-lambda exp))
        ((begin?       exp) (analyze-sequence (begin-actions exp)))
        ((cond?        exp) (analyze (cond->if exp)))
        ((application? exp) (analyze-application exp))
        (else (error 'ANALYZE exp))))

(define (analyze-self-evaluating exp)
   (lambda (env) exp))

(define (analyze-quoted exp)
   (let ((qval (text-of-quotation exp)))
      (lambda (env) qval)))

(define (analyze-variable exp)
   (lambda (env) (lookup-variable-value exp env)))

(define (analyze-assignment exp)
  (let ((var   (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env)
      (set-variable-value! var (vproc env) env)
      'ok)))

(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env)
      (define-variable! var (vproc env) env)
      'ok)))

(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
    (lambda (env)
      (if (true? (pproc env))
          (cproc env)
          (aproc env)))))

(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env) (make-procedure vars bproc env))))

(define (analyze-sequence exps)
   (define (sequentially proc1 proc2)   (lambda (env) (proc1 env) (proc2 env)))
   (define (loop first-proc rest-procs) (if (null? rest-procs)
                                              first-proc
                                           (loop (sequentially first-proc (car rest-procs))
                                                 (cdr rest-procs))))
   (let ((procs (map analyze exps)))
      (if (null? procs)
            (error 'ANALYZE "empty sequence"))
      (loop (car procs) (cdr procs))))

(define (analyze-application exp)
   (let ((fproc (analyze (operator exp)))
         (aprocs (map analyze (operands exp))))
      (lambda (env)
         (execute-application (fproc env)
                              (map (lambda (aproc) (aproc env))
                                   aprocs)))))

(define (execute-application proc args)
   (cond ((primitive-procedure? proc) (apply-primitive-procedure proc args))
         ((compound-procedure? proc)  ((procedure-body proc) (extend-environment (procedure-parameters proc) args (procedure-environment proc))))
         (else (error 'EXECUTE-APPLICATION proc))))


##
##  CHAPTER 5 OF STRUCTURE AND INTERPRETATION OF COMPUTER PROGRAMS
##

## 
## <register-name>  = ...
## <constant-value> = ...
## <input<x>>       = (reg <register-name>) or (const <constant-value>)
##
## (assign <register-name> (reg <register-name>))
## (assign <register-name> (const <constant-value>))
## (assign <register-name> (op <operation-name>) <input1> ... <inputn>)
## (perform (op <operation-name>) <input1> ... <inputn>)
## (test    (op <operation-name>) <input1> ... <inputn>)
## (branch  (label <label-name>))
## (goto    (label <label-name>))
## (assign <register-name> (label <label-name>))
## (goto   (reg <register-name>))
## (save <register-name>)
## (restore <register-name>)

##
## Chapter 5 Section 5
##


