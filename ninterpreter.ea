(require "boot.ea")

##
## Fixed Operators
##  define, quote, type, if, and, or, set, delay, while, begin, let, lambda
##

(define (control? val) (isA? val :control))

##
## find-value modelled after (kernal.c:eval_symbol)
##
(define (find-value symbol context)
   (let (match entry)
      (set match (lambda (binding) (== (element binding 0) symbol)))
      (set entry (find match context))
      (if (nil? entry)
            (find-value symbol (environment))
         (element entry 1))))

##
## make-bindings modelled after (kernal.c:apply_lambda)
##
(define (make-bindings formals args closure)
   (if (nil? formals) 
         closure
      (if (pair? formals)
            (cons (cons (car formals) (car args))
                  (make-bindings (cdr formals) (cdr args) closure))
         (cons (cons formals args) closure))))

(define (update-bindings symbol value env)
   (let ((binding (car env)))
      (if (== symbol (car binding))
            (cdr binding value)
         (update-bindings symbol value (cdr env)))))
         

##
## expander modelled after (apply.c:expand)
## syntax-tree -> syntax-tree
## 
(define (expander exp env)
   (let (expand-list do-expand apply-form)
      (set do-expand 
           (lambda (item)
              (expander item env)))
      (set expand-list
           (lambda (exp)
              (let ((head (expander (car exp) env))
                    (tail (cdr exp)))
                 (cond ((== head 'quote) (cons head tail))
                       ((== head 'type)  (cons head tail))
                       ((symbol? head)   (let ((value (find-value head env)))
                                            (if (form? value)
                                                  (apply-form value tail)
                                               (cons head (map do-expand tail)))))
                       (else (cons head (map do-expand tail)))))))
      (set apply-form
           (lambda (form args)
              (let ((action (form-action form)))
                 (if (nil? action)
                       (map do-expand args)
                    (application action args env)))))
      (cond ((pair? exp) (expand-list exp))
            (else        exp))))

##
## encoder modelled after (apply.c:encode)
## syntax-tree -> control-tree (global control/primitives)
##
(define (encoder exp env)
   (let (do-encode encode-list apply-encoder)
      (set (do-encode item) (encoder item env))
      (set (encode-list exp)
           (let ((head (encoder (car exp) env))
                 (tail (cdr exp)))
              (if (symbol? head)
                    (let ((value (find-value head env)))
                       (cond ((primitive? value) (cons value (map do-encode tail)))
                             ((control? value)   (cons value (control-encoder value tail)))
                             (else               (cons head  (map do-encode tail)))))
                 (cons head (map do-encode tail)))))
      (set (let-binding entry)
           (cond ((symbol? entry) entry)
                 ((pair?   entry) (car entry))
                 ((tuple?  entry) (element entry 0))))
      (set (control-encoder control tail)
           (let (check name)
              (set name (control-name control))
              (set (check symbol) (== symbol name))
              (cond ((check 'define) (cons (car tail) (map do-encode (cdr tail))))
                    ((check 'quote)  tail)
                    ((check 'type)   tail)
                    ((check 'if)     (map do-encode tail))
                    ((check 'and)    (map do-encode tail))
                    ((check 'or)     (map do-encode tail))
                    ((check 'set)    (cons (car tail) (map do-encode (cdr tail))))
                    ((check 'delay)  (map do-encode tail))
                    ((check 'begin)  (map do-encode tail))
                    ((check 'let)    (let ((nenv (make-bindings (map let-binding (car tail)) nil env)))
                                        (map (lambda (item)
                                                (encoder item nenv))
                                             tail)))
                    ((check 'lambda) (let ((nenv (make-bindings (map let-binding (car tail)) nil env)))
                                        (cons (car tail) (map (lambda (item)
                                                                 (encoder item nenv))
                                                              (cdr tail)))))
                    )))
      (cond ((pair? exp) (encode-list exp env))
            (else        exp))))

##
## evaluator modelled after (apply.c:eval)
## control-tree -> value
## 
(define (evaluator exp env)
   (let (do-eval make-let-bindings control-evaluator)
      ## do-eval           - convert an control-tree argument into a value
      ## make-let-bindings - create and extended enviroment
      ## control-evaluator - convert a control-tree structure into a value
      (set (do-eval item) (evaluator item env))
      (set (make-let-bindings bindings) 
           (if (nil? bindings)
                 env
              (let ((entry (car bindings))
                    (tail  (make-let-bindings (cdr bindings))))
                 (cond ((symbol? entry) (cons (cons entry nil) tail))
                       ((pair?  entry) (cons (cons (car entry) 
                                                   (evaluator (car (cdr entry)) env))
                                             tail))
                       ((tuple? entry) (cons (cons (element entry 0)
                                                   (evaluator (element entry 1) env))
                                             tail))))))
      (set (control-evaluator control args)
           (let (check name)
              (set name (control-name control))
              (set (check symbol) (== symbol name))
              (cond ((check 'define) (let ((symbol (car args))
                                           (value (car (cdr args))))
                                        (global-add symbol (evaluator value env))))
                    ((check 'quote)  (car args))
                    ((check 'type)   (type args))
                    ((check 'if)     (let ((test     (car args))
                                           (on_true  (car (cdr args)))
                                           (on_false (cdr (cdr args))))
                                        (if (evaluator exp env)
                                              (evaluator on_true env)
                                           (control-evaluator 'begin on_false))))
                    ((check 'and)    (if (nil? args)
                                           true
                                        (if (nil? (evaluator (car args) env))
                                              nil
                                           (control-evaluator 'and (cdr args)))))
                    ((check 'or)     (if (nil? args)
                                           nil
                                        (if (nil? (evaluator (car args) env))
                                              (control-evaluator 'or (cdr args))
                                           nil)))
                    ((check 'set)    (let ((symbol (car args))
                                           (value  (evaluator (car (cdr args)) env)))
                                        (update-bindings symbol value env)))
                    ((check 'delay)  (let ((value (tuple nil (car args) env)))
                                        (type-of value :delay)
                                        value))
                    ((check 'begin)  (if (nil? (cdr args))
                                           (evaluator (car args) env)
                                        (evaluator (car args) env)
                                        (control-evaluator 'begin (cdr args))))
                    ((check 'let)    (let ((nenv (make-let-bindings (car args))))
                                        (control-evaluator 'begin (cdr args))))
                    ((check 'lambda) (let ((value (cons args env)))
                                        (type-of value :lambda)
                                        value))                    
                    )))
      (cond ((primitive? exp) exp)
            ((control?   exp) exp)
            ((symbol?    exp) (let ((value (find-value exp env)))
                                 (if (forced? value)
                                       (forced-value value)
                                    value)))
            ((pair?      exp) (let ((head (do-eval (car exp)))
                                    (tail (cdr exp)))
                                 (cond ((control? head)   (control-evaluator head tail))
                                       ((primitive? head) (application head (map do-eval tail) env))
                                       ((symbol? head)    (evaluator (cons (find-value exp env) tail) env))
                                       ((delay? head)     (evaluator (cons (force head) tail) env))
                                       (else              (application head (map do-eval tail) env)))))
            (else exp))))

##
## registers modelled after evaluator
## control-tree -> set (escaping names)
##
(define (registers exp env)
   (let (global? control-registers do-register fetch-entry)
      ## global?           - check if a symbol is global in this envirment
      ## control-registers - deal with control-tree structures
      ## do-registers      - return the set of registers used by an argument
      ## fetch-entry       - check if an value is a control or primitive
      (cond ((primitive? exp) nil)
            ((control?   exp) nil)
            ((symbol?    exp) (if (global? exp) nil (cons exp nil)))
            ((pair?      exp) (let ((head (fetch-entry (car exp)))
                                    (tail (cdr exp)))
                                 (cond ((control? head)   (control-registers head tail))
                                       ((primitive? head) (union (map do-register tail) nil))
                                       ((symbol? head)    (union (map do-register tail) (cons head nil)))
                                       (else (error 'REGISTER "unknown operator " head)))))
            (else nil))))
##
##  application modelled after (apply.c:apply)
##
(define (application action args env)
   (let (eval-begin)
      (set eval-begin 
           (lambda (body context)
              (if (nil? (cdr body))
                    (evaluator (car body) context)
                 (evaluator (car body) context)
                 (eval-begin (cdr body) context))))
      (cond ((primitive? action) (apply action args env))
            ((lambda? action)    (let ((defn    (element action 0))
                                       (closure (element action 1)))
                                    (let ((formals (element defn 0))
                                          (body    (element defn 1)))
                                       (eval-begin body (make-bindings formals args closure))))))))

