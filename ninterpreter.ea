(require "boot.ea")

##
## Fixed Operators
##  define, quote, type, if, and, or, set, delay, while, begin, let, lambda
##

(define (control? val) (isA? val :control))

## needed when we expand the syntax tree to include then
(define (comma?   val) (isA? val :comma))
(define (semi?    val) (isA? val :semi))
(define (block?   val) (isA? val :block))

(define (make-controls list)
   (if (nil? list)
         nil
      (let (symbol value)
         (set symbol (car list))
         (set value (tuple symbol))
         (type-of value :control)
         (cons (cons symbol value) (make-controls (cdr list))))))

(define globals  (cons 'globals nil))
(define (global-add symbol value)
   (dumpln "adding global " symbol " = " value)
   (cdr globals (cons (cons symbol value) (cdr globals))))

(define controls (make-controls '(define quote type if and or set delay while begin let lambda)))
(define (control-name control) (car control))

##
## find-value modelled after (kernal.c:eval_symbol)
##
(define (find-value symbol context)
   (let (match entry)
      (set match (lambda (binding) (== (element binding 0) symbol)))
      (set entry (find match context))
      (if (nil? entry)
            (set entry (find match controls)))
      (if (nil? entry)
            (set entry (find match (cdr globals))))
      (if (nil? entry)
            (set entry (find match (environment))))
      (if (nil? entry)
            nil
         (println symbol " = " (element entry 1))
         (element entry 1))))

##
## make-bindings modelled after (kernal.c:apply_lambda)
##
(define (make-bindings formals args closure)
   (if (nil? formals) 
         closure
      (if (pair? formals)
            (cons (cons (car formals) (car args))
                  (make-bindings (cdr formals) (cdr args) closure))
         (cons (cons formals args) closure))))

(define (update-bindings symbol value env)
   (let ((binding (car env)))
      (if (== symbol (car binding))
            (cdr binding value)
         (update-bindings symbol value (cdr env)))))

##
## expander modelled after (apply.c:expand)
## syntax-tree -> syntax-tree
## 
(define (expander exp env)
   (let (expand-list do-expand apply-form)
      (set (do-expand item)
           (expander item env))
      (set (expand-list exp)
           (let ((head (expander (car exp) env))
                 (tail (cdr exp)))
              (cond ((== head 'quote) (cons head tail))
                    ((== head 'type)  (cons head tail))
                    ((symbol? head)   (let ((value (find-value head env)))
                                         (if (form? value)
                                               (apply-form value tail)
                                            (cons head (map do-expand tail)))))
                    (else (cons head (map do-expand tail))))))
      (set (apply-form form args)
           (let ((action (form-action form)))
              (if (nil? action)
                    (map do-expand args)
                 (application action args env))))
      (cond ((pair? exp) (expand-list exp))
            ((tuple?   exp) exp)
            ((symbol?  exp) exp)
            ((text?    exp) exp)
            ((integer? exp) exp)
            ((nil?     exp) exp)
            ((comma?   exp) (error 'EXPANDER "comma not supported (yet)" exp))
            ((semi?    exp) (error 'EXPANDER "semi not supported (yet)" exp))
            ((block?   exp) (error 'EXPANDER "block not supported (yet)" exp))
            (else  (error 'ENCODER "invalid type in a syntax-tree" exp))
            )))

##
## encoder modelled after (apply.c:encode)
## syntax-tree -> control-tree (global control/primitives)
##
(define (encoder exp env)
   (let (do-encode encode-list let-binding control-encoder apply-encoder)
      (set (do-encode item) (encoder item env))
      (set (encode-list exp)
           (let ((head (encoder (car exp) env))
                 (tail (cdr exp)))
              (if (symbol? head)
                    (let ((value (find-value head env)))
                       (cond ((primitive? value) (cons value (map do-encode tail)))
                             ((control? value)   (cons value (control-encoder value tail)))
                             (else               (cons head  (map do-encode tail)))))
                 (cons head (map do-encode tail)))))
      (set (let-binding entry)
           (cond ((symbol? entry) entry)
                 ((pair?   entry) (car entry))
                 ((tuple?  entry) (element entry 0))))
      (set (control-encoder control tail)
           (let (check name)
              (set name (control-name control))
              (set (check symbol) (== symbol name))
              (cond ((check 'define) (cons (car tail) (map do-encode (cdr tail))))
                    ((check 'quote)  tail)
                    ((check 'type)   tail)
                    ((check 'if)     (map do-encode tail))
                    ((check 'and)    (map do-encode tail))
                    ((check 'or)     (map do-encode tail))
                    ((check 'set)    (cons (car tail) (map do-encode (cdr tail))))
                    ((check 'delay)  (map do-encode tail))
                    ((check 'begin)  (map do-encode tail))
                    ((check 'let)    (let ((nenv (make-bindings (map let-binding (car tail)) nil env)))
                                        (map (lambda (item)
                                                (encoder item nenv))
                                             tail)))
                    ((check 'lambda) (let ((nenv (make-bindings (map let-binding (car tail)) nil env)))
                                        (cons (car tail) (map (lambda (item)
                                                                 (encoder item nenv))
                                                              (cdr tail)))))
                    )))
      (cond ((pair?    exp) (encode-list exp))
            ((tuple?   exp) exp)
            ((symbol?  exp) exp)
            ((text?    exp) exp)
            ((integer? exp) exp)
            ((nil?     exp) exp)
            ((comma?   exp) (error 'ENCODER "comma not supported (yet)" exp))
            ((semi?    exp) (error 'ENCODER "semi not supported (yet)" exp))
            ((block?   exp) (error 'ENCODER "block not supported (yet)" exp))
            (else  (error 'ENCODER "invalid type in a syntax-tree" exp))
            )))

##
## evaluator modelled after (apply.c:eval)
## control-tree -> value
## 
(define (evaluator exp env)
   (let (do-eval make-let-bindings control-evaluator)
      ## do-eval           - convert an control-tree argument into a value
      ## make-let-bindings - create and extended enviroment
      ## control-evaluator - convert a control-tree structure into a value
      (set (do-eval item) (evaluator item env))
      (set (make-let-bindings bindings) 
           (if (nil? bindings)
                 env
              (let ((entry (car bindings))
                    (tail  (make-let-bindings (cdr bindings))))
                 (cond ((symbol? entry) (cons (cons entry nil) tail))
                       ((pair?  entry) (cons (cons (car entry) 
                                                   (evaluator (car (cdr entry)) env))
                                             tail))
                       ((tuple? entry) (cons (cons (element entry 0)
                                                   (evaluator (element entry 1) env))
                                             tail))))))
      (set (control-evaluator control args)
           (let (check name)
              (set name (control-name control))
              (dumpln "control-evaluator " name " args " args)
              (set (check symbol) (== symbol name))
              (cond ((check 'define) (let ((symbol (car args))
                                           (value (car (cdr args))))
                                        (global-add symbol (evaluator value env))))
                    ((check 'quote)  (car args))
                    ((check 'type)   (type args))
                    ((check 'if)     (let ((test     (car args))
                                           (on_true  (car (cdr args)))
                                           (on_false (cdr (cdr args))))
                                        (if (evaluator exp env)
                                              (evaluator on_true env)
                                           (control-evaluator 'begin on_false))))
                    ((check 'and)    (if (nil? args)
                                           true
                                        (if (nil? (evaluator (car args) env))
                                              nil
                                           (control-evaluator 'and (cdr args)))))
                    ((check 'or)     (if (nil? args)
                                           nil
                                        (if (nil? (evaluator (car args) env))
                                              (control-evaluator 'or (cdr args))
                                           nil)))
                    ((check 'set)    (let ((symbol (car args))
                                           (value  (evaluator (car (cdr args)) env)))
                                        (update-bindings symbol value env)))
                    ((check 'delay)  (let ((value (tuple nil (car args) env)))
                                        (type-of value :delay)
                                        value))
                    ((check 'begin)  (if (nil? (cdr args))
                                           (evaluator (car args) env)
                                        (evaluator (car args) env)
                                        (control-evaluator 'begin (cdr args))))
                    ((check 'let)    (let ((nenv (make-let-bindings (car args))))
                                        (control-evaluator 'begin (cdr args))))
                    ((check 'lambda) (let ((value (cons args env)))
                                        (type-of value :lambda)
                                        value))                    
                    )))
      (cond ((primitive? exp) exp)
            ((control?   exp) exp)
            ((symbol?    exp) (let ((value (find-value exp env)))
                                 (if (forced? value)
                                       (forced-value value)
                                    value)))
            ((pair?      exp) (let ((head (do-eval (car exp)))
                                    (tail (cdr exp)))
                                 (cond ((control? head)   (control-evaluator head tail))
                                       ((primitive? head) (application head (map do-eval tail) env))
                                       ((symbol? head)    (evaluator (cons (find-value exp env) tail) env))
                                       ((delay? head)     (evaluator (cons (force head) tail) env))
                                       (else              (application head (map do-eval tail) env)))))
            ((tuple?   exp) exp)
            ((text?    exp) exp)
            ((integer? exp) exp)
            ((nil?     exp) exp)
            ((comma?   exp) (error 'EVALUATOR "comma not supported (yet)" exp))
            ((semi?    exp) (error 'EVALUATOR "semi not supported (yet)" exp))
            ((block?   exp) (error 'EVALUATOR "block not supported (yet)" exp))
            (else exp))))

##
## registers modelled after evaluator
## control-tree -> set (escaping names)
##
(define (registers exp env)
   (let (global? control-registers do-register fetch-entry)
      ## global?           - check if a symbol is global in this envirment
      ## control-registers - deal with control-tree structures
      ## do-registers      - return the set of registers used by an argument
      ## fetch-entry       - check if an value is a control or primitive
      (cond ((primitive? exp) nil)
            ((control?   exp) nil)
            ((symbol?    exp) (if (global? exp) nil (cons exp nil)))
            ((pair?      exp) (let ((head (fetch-entry (car exp)))
                                    (tail (cdr exp)))
                                 (cond ((control? head)   (control-registers head tail))
                                       ((primitive? head) (union (map do-register tail) nil))
                                       ((symbol? head)    (union (map do-register tail) (cons head nil)))
                                       (else (error 'REGISTER "unknown operator " head)))))
            (else nil))))
##
##  application modelled after (apply.c:apply)
##
(define (application action args env)
   (dumpln "application " action " args " args)
   (let (eval-begin)
      (set (eval-begin body context)
           (dumpln "eval-begin " body)
           (if (nil? (cdr body))
                 (evaluator (car body) context)
              (evaluator (car body) context)
              (eval-begin (cdr body) context)))
      (cond ((primitive? action) (let ((output  (apply action args env)))
                                    (dumpln action " args " args " -> " output)
                                    output))
            ((lambda? action)    (let ((defn    (element action 0))
                                       (closure (element action 1)))
                                    (let ((formals (element defn 0))
                                          (body    (element defn 1)))
                                       (eval-begin body (make-bindings formals args closure))))))))

