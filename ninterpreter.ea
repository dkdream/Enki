(require "boot.ea")

##
## Fixed Operators
##  define, quote, type, if, unless, and, or, set, delay, while, begin, let, lambda
##

(define (control? val) (isA? val :control))

## needed when we expand the syntax tree to include then
(define (comma?   val) (isA? val :comma))
(define (semi?    val) (isA? val :semi))
(define (block?   val) (isA? val :block))
(define (nlambda? val) (isA? val :n_lambda))
(define (ndelay?  val) (isA? val :n_delay))

(define (make-controls list)
   (if (nil? list)
         nil
      (let (symbol value)
         (set symbol (car list))
         (set value (tuple symbol))
         (type-of value :control)
         (cons (cons symbol value) (make-controls (cdr list))))))

(define globals  (cons 'globals nil))
(define (global-add symbol value)
   (println "global-store " symbol " " value)
   (cdr globals (cons (cons symbol value) (cdr globals))))

(define controls (make-controls '(define quote type if unless and or set delay while begin let lambda)))
(define (control-name control) (car control))


##
## find-value modelled after (kernal.c:eval_symbol)
##
(define (find-value symbol context)
   (let (match entry value)
      (set match (lambda (binding) (== (element binding 0) symbol)))
      (set entry (find match context))
      (if (nil? entry)
            (set entry (find match (cdr globals))))
      (if (nil? entry)
            (set entry (find match controls)))
      (if (nil? entry)
            (set entry (find match (environment))))
      (if (nil? entry)
            nil
         (set value (element entry 1))
         value)))

##
## make-bindings modelled after (kernal.c:apply_lambda)
##
(define (make-bindings formals args closure)
   (if (nil? formals) 
         closure
      (if (pair? formals)
            (let ((entry (cons (car formals) (car args))))
               (cons entry
                     (make-bindings (cdr formals) (cdr args) closure)))
         (cons (cons formals args) closure))))

(define (update-bindings symbol value env)
   (let (match entry)
      (set match (lambda (binding) (== (element binding 0) symbol)))
      (set entry (find match env))
      (if (nil? entry)
            (println "unable to set local " symbol " in " env)
         (cdr entry value))))

##
## expander modelled after (apply.c:expand)
## syntax-tree -> hybrid-syntax-tree (macro added: control/primitive)
## 
(define (expander exp env)
   (let (expand-list apply-form do-expand)
      (set (do-expand item)
           (expander item env))
      (set (apply-form form args)
           (let ((action (form-action form)))
              (if (nil? action)
                    (map do-expand args)
                 (do-expand (application action args env)))))
      (set (expand-list exp)
           (let ((head (expander (car exp) env))
                 (tail (cdr exp)))
              (cond ((== head 'quote) (cons head tail))
                    ((== head 'type)  (cons head tail))
                    ((symbol? head)   (let ((value (find-value head env)))
                                         (if (form? value)
                                               (apply-form value tail)
                                            (cons head (map do-expand tail)))))
                    (else (cons head (map do-expand tail))))))
      (cond ((pair? exp) (expand-list exp))
            ((tuple?     exp) exp)
            ((symbol?    exp) exp)
            ((text?      exp) exp)
            ((integer?   exp) exp)
            ((nil?       exp) exp)
            ((primitive? exp) exp) ## added by a macro
            ((control?   exp) exp) ## added by a macro
            ((comma?     exp) (error 'EXPANDER "comma not supported (yet)" exp))
            ((semi?      exp) (error 'EXPANDER "semi not supported (yet)" exp))
            ((block?     exp) (error 'EXPANDER "block not supported (yet)" exp))
            (else (begin
                      (println "----------------------")
                      (dumpln exp)
                      (error 'EXPANDER "invalid type in a syntax-tree" exp)))
            )))

##
## encoder modelled after (apply.c:encode)
## hybrid-syntax-tree -> control-tree (global control/primitives)
##
(define (encoder exp env)
   (let (do-encode encode-list let-binding control-encoder apply-encoder)
      (set (do-encode item) (encoder item env))
      (set (encode-list exp)
           (let ((head (encoder (car exp) env))
                 (tail (cdr exp)))
              (if (symbol? head)
                    (let ((value (find-value head env)))
                       (cond ((primitive? value) (cons value (map do-encode tail)))
                             ((control? value)   (cons value (control-encoder value tail)))
                             (else               (cons head  (map do-encode tail)))))
                 (cons head (map do-encode tail)))))
      (set (let-binding entry)
           (cond ((symbol? entry) entry)
                 ((pair?   entry) (car entry))
                 ((tuple?  entry) (element entry 0))))
      (set (control-encoder control tail)
           (let (check name)
              (set name (control-name control))
              (set (check symbol) (== symbol name))
              (cond ((check 'define) (cons (car tail) (map do-encode (cdr tail))))
                    ((check 'quote)  tail)
                    ((check 'type)   tail)
                    ((check 'if)     (map do-encode tail))
                    ((check 'unless) (map do-encode tail))
                    ((check 'and)    (map do-encode tail))
                    ((check 'or)     (map do-encode tail))
                    ((check 'set)    (cons (car tail) (map do-encode (cdr tail))))
                    ((check 'delay)  (map do-encode tail))
                    ((check 'begin)  (map do-encode tail))
                    ((check 'let)    (let ((nenv (make-bindings (map let-binding (car tail)) nil env)))
                                        (map (lambda (item)
                                                (encoder item nenv))
                                             tail)))
                    ((check 'lambda) (let ((nenv (make-bindings (map let-binding (car tail)) nil env)))
                                        (cons (car tail) (map (lambda (item)
                                                                 (encoder item nenv))
                                                              (cdr tail)))))
                    )))
      (cond ((pair?      exp) (encode-list exp))
            ((tuple?     exp) exp)
            ((symbol?    exp) exp)
            ((text?      exp) exp)
            ((integer?   exp) exp)
            ((nil?       exp) exp)
            ((primitive? exp) exp) ## added by a macro
            ((control?   exp) exp) ## added by a macro
            ((comma?     exp) (error 'ENCODER "comma not supported (yet)" exp))
            ((semi?      exp) (error 'ENCODER "semi not supported (yet)" exp))
            ((block?     exp) (error 'ENCODER "block not supported (yet)" exp))
            (else  (begin
                      (println "----------------------")
                      (dumpln exp)
                      (error 'ENCODER "invalid type in a syntax-tree")))
            )))

##
## evaluator modelled after (apply.c:eval)
## control-tree -> value
## 
(define (evaluator exp env)
   (let (do-eval make-let-bindings control-evaluator cbegin)
      ## do-eval           - convert an control-tree argument into a value
      ## make-let-bindings - create and extended enviroment
      ## control-evaluator - convert a control-tree structure into a value
      (set cbegin (find-value 'begin controls))
      (set (do-eval item) (evaluator item env))
      (set (make-let-bindings bindings)
           (if (nil? bindings)
                 env
              (let ((entry (car bindings))
                    (tail  (make-let-bindings (cdr bindings))))
                 (cond ((symbol? entry) (cons (cons entry nil) tail))
                       ((pair?  entry) (cons (cons (car entry) 
                                                   (evaluator (car (cdr entry)) env))
                                             tail))
                       ((tuple? entry) (cons (cons (element entry 0)
                                                   (evaluator (element entry 1) env))
                                             tail))))))
      (set (control-evaluator control args)
           (let (check name)
              (set name (control-name control))
              (set (check symbol) (== symbol name))
              (cond ((check 'define) (let ((symbol (car args))
                                           (value (car (cdr args))))
                                        (global-add symbol (evaluator value env))))
                    ((check 'quote)  (car args))
                    ((check 'type)   (type args))
                    ((check 'if)     (let ((test     (car args))
                                           (on_true  (car (cdr args)))
                                           (on_false (cdr (cdr args))))
                                        (if (evaluator test env)
                                              (evaluator on_true env)
                                           (control-evaluator cbegin on_false))))
                    ((check 'unless) (let ((test     (car args))
                                           (on_true  (car (cdr args)))
                                           (on_false (cdr (cdr args))))
                                        (if (evaluator exp env)
                                              (control-evaluator cbegin on_false)
                                           (evaluator on_true env))))
                    ((check 'and)    (if (nil? args)
                                           true
                                        (if (nil? (evaluator (car args) env))
                                              nil
                                           (control-evaluator control (cdr args)))))
                    ((check 'or)     (if (nil? args)
                                           nil
                                        (if (nil? (evaluator (car args) env))
                                              (control-evaluator control (cdr args))
                                           nil)))
                    ((check 'set)    (let ((symbol (car args))
                                           (value  (evaluator (car (cdr args)) env)))
                                        (update-bindings symbol value env)))
                    ((check 'delay)  (let ((value (tuple nil (car args) env)))
                                        (type-of value :n_delay)
                                        value))
                    ((check 'begin)  (if (nil? (cdr args))
                                           (evaluator (car args) env)
                                        (evaluator (car args) env)
                                        (control-evaluator control (cdr args))))
                    ((check 'let)    (let ((nenv (make-let-bindings (car args))))
                                        (evaluator (cons cbegin (cdr args)) nenv)))
                    ((check 'lambda) (let ((value (cons args env)))
                                        (type-of value :n_lambda)
                                        value))
                    )))
      (cond ((primitive? exp) exp)
            ((control?   exp) exp)
            ((symbol?    exp) (let ((value (find-value exp env)))
                                 (if (forced? value)
                                       (forced-value value)
                                    value)))
            ((pair?      exp) (let ((head (do-eval (car exp)))
                                    (tail (cdr exp)))
                                 (cond ((control? head)   (control-evaluator head tail))
                                       ((primitive? head) (application head (map do-eval tail) env))
                                       ((symbol? head)    (evaluator (cons (find-value exp env) tail) env))
                                       ((ndelay? head)    (evaluator (cons (force head) tail) env))
                                       (else              (application head (map do-eval tail) env)))))
            ((tuple?   exp) exp)
            ((text?    exp) exp)
            ((integer? exp) exp)
            ((nil?     exp) exp)
            ((comma?   exp) (error 'EVALUATOR "comma not supported (yet)" exp))
            ((semi?    exp) (error 'EVALUATOR "semi not supported (yet)" exp))
            ((block?   exp) (error 'EVALUATOR "block not supported (yet)" exp))
            (else exp))))

##
##  application modelled after (apply.c:apply)
##
(define (application action args env)
   (let (eval-begin)
      (set (eval-begin body context)
           (if (nil? (cdr body))
                 (evaluator (car body) context)
              (evaluator (car body) context)
              (eval-begin (cdr body) context)))
      (cond ((primitive? action) (let ((output  (apply action args env)))
                                    output))
            ((lambda? action) (let ((output  (apply action args env)))
                                  output))
            ((nlambda? action)    (let ((defn    (element action 0))
                                        (closure (element action 1)))
                                     (let ((formals (element defn 0))
                                           (body    (element defn 1)))
                                        (eval-begin body (make-bindings formals args closure))))))))

(global-add 'expand expander)
(global-add 'encode encoder)
(global-add 'eval   evaluator)
(global-add 'apply  application)

(define (undefined name)
   (global-add name (lambda args
                       (error NAME "is not defined in this context"))))

(undefined 'map)
(undefined 'find)
(undefined 'require)

(define (readFile in)
   (if (eof-in in)
         nil
      (let ((value (read-sexpr in)))
         (println)
         (println)
         (dumpln "read " value)
         (set value (expander value nil))
         (dumpln "expanded " value)
         (set value (encoder value nil))
         (dumpln "encoded " value)
         (set value (evaluator value nil))
         (dumpln "value " value))
      (readFile in)))

